{
  "language": "Solidity",
  "sources": {
    "contracts/ifo/EMOPrivateSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport './TokenPrivateSale.sol';\n\ncontract EMOPrivateSale is TokenPrivateSale {\n\n    constructor(\n            address _treasury, \n            address _keeper, \n            address _usdc,\n            address _token, \n            uint256 _tokenPrice, \n            uint256 _basePrice,\n            uint256 _minTokensAmount, \n            uint256 _maxTokensAmount, \n            uint256 _privateSaleTokenPool,\n            uint256 _privateSaleStart, \n            uint256 _privateSaleEnd, \n            uint256 _vestingDuration\n        ) public TokenPrivateSale (\n            _treasury,\n            _keeper,\n            _usdc,\n            _token,\n            _tokenPrice,\n            _basePrice,\n            _minTokensAmount,\n            _maxTokensAmount,\n            _privateSaleTokenPool,\n            _privateSaleStart,\n            _privateSaleEnd,\n            _vestingDuration\n    ) {}\n\n    function getName() external pure returns (string memory) {\n        return \"EMOPrivateSale\";\n    }\n}"
    },
    "contracts/ifo/TokenPrivateSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function latestRoundData() external view returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    );\n}\n\ncontract TokenPrivateSale is Ownable, Pausable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * EVENTS\n     **/\n    event TokenPurchased(address indexed user, address coin, uint256 coinAmount, uint256 tokenAmount);\n    event TokensClaimed(address indexed user, uint256 tokenAmount);\n\n    /**\n     * CONSTANTS\n     **/\n\n    // *** support coin ***\n    address public USDC;\n\n    // *** SALE PARAMETERS ***\n    uint256 public constant PRECISION = 1000000; //Up to 0.000001\n    uint256 public constant WITHDRAWAL_PERIOD = 395 * 24 * 60 * 60; //0.5 year to withdrawal\n\n    /***\n     * STORAGE\n     ***/\n    uint256 public minTokensAmount; // minimum amount of TOKEN to buy per tx,like 1000 * 1e18\n    uint256 public maxTokensAmount; // maximum amount of TOKEN each address can buy\n    uint256 public maxGasPrice; // mitigate front running\n\n    // *** SALE PARAMETERS START ***\n    AggregatorV3Interface public priceFeed;\n    uint256 public  privateSaleStart;\n    uint256 public  privateSaleEnd;\n    uint256 public  privateSaleTokenPool; // total amount of Token in private-sale pool\n\n    // *** SALE PARAMETERS END ***\n\n    // *** VESTING PARAMETERS START ***\n\n    uint256 public vestingStart;\n    uint256 public vestingDuration;\n\n    // *** VESTING PARAMETERS END ***\n\n    address public token; // ATTENTION! Decimal of token should be 1e18\n    uint256 public tokenPrice; // the price of token in usd multiply by PRECISION\n    mapping(address => uint256) public purchased;\n    mapping(address => uint256) internal _claimed;\n    mapping(address => bool) public whitelisted;\n\n    uint256 public purchasedPrivateSale;\n    uint256 public basePrice; // the price of ETH in usd multiply by PRECISION\n\n    address private treasury;\n    address private keeper;\n\n    /***\n     * MODIFIERS\n     ***/\n\n    /**\n    * @dev Throws if address is not owner or keeper.\n    */\n    modifier onlyKeeper() {\n        require(_msgSender() == owner() || _msgSender() == keeper, \"!Keeper\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called when no ongoing private-sale or public sale.\n    */\n    modifier onlySale() {\n        require(_isPrivateSale(), \"PrivateSale stages are over or not started\");\n        _;\n    }\n\n    /**\n    * @dev Throws if sale stage is ongoing.\n    */\n    modifier notOnSale() {\n        require(!_isPrivateSale(), \"PrivateSale is not over\");\n        _;\n    }\n\n    /**\n    * @dev Throws if gas price exceeds gas limit.\n    */\n    modifier correctGas() {\n        require(maxGasPrice == 0 || tx.gasprice <= maxGasPrice, \"Gas price exceeds limit\");\n        _;\n    }\n\n    /**\n    * @dev Throws if address is not on the whitelist.\n    */\n    modifier onlyWhitelist(address user) {\n        require(whitelisted[user], \"Address is not on the whitelist\");\n        _;\n    }\n\n    /***\n     * INITIALIZER AND SETTINGS\n     ***/\n\n    constructor(address _treasury, address _keeper, address _usdc,\n        address _token, uint256 _tokenPrice, uint256 _basePrice,\n        uint256 _minTokensAmount, uint256 _maxTokensAmount, uint256 _privateSaleTokenPool,\n        uint256 _privateSaleStart, uint256 _privateSaleEnd, uint256 _vestingDuration) public {\n        require(_treasury != address(0), \"!treasury\");\n        require(_token != address(0), \"!token\");\n        require(_privateSaleStart > 0, \"!start\");\n        require(_privateSaleEnd > _privateSaleStart, \"start >= end\");\n        require(_vestingDuration < WITHDRAWAL_PERIOD, \"vestingDuration >= WITHDRAWAL_PERIOD\");\n\n        treasury = _treasury;\n        keeper = _keeper;\n\n        USDC = _usdc;\n        token = _token;\n        tokenPrice = _tokenPrice;\n        basePrice = _basePrice;\n\n        minTokensAmount = _minTokensAmount;\n        maxTokensAmount = _maxTokensAmount;\n        privateSaleTokenPool = _privateSaleTokenPool;\n\n        privateSaleStart = _privateSaleStart;\n        privateSaleEnd = _privateSaleEnd;\n        vestingDuration = _vestingDuration;\n    }\n\n    /**\n    * @notice Updates current priceFeed of chainlink.\n    * @param _priceFeed New priceFeed\n    */\n    function adminSetPriceFeed(address _priceFeed) external onlyOwner {\n        priceFeed = AggregatorV3Interface(_priceFeed);\n    }\n\n    /**\n     * @notice Updates current vesting start time. Can be used once\n     * @param _vestingStart New vesting start time\n     */\n    function adminSetVestingStart(uint256 _vestingStart) external onlyOwner {\n        require(vestingStart == 0, \"Vesting start is already set\");\n        require(_vestingStart >= privateSaleEnd && block.timestamp < _vestingStart, \"Incorrect time provided\");\n        vestingStart = _vestingStart;\n    }\n\n    /**\n    * @notice Sets the rate based on the contracts precision\n    * @param _price The price of ETH multiple by precision (e.g. _rate = PRECISION corresponds to $1)\n    */\n    function adminSetBasePrice(uint256 _price) external onlyKeeper {\n        basePrice = _price;\n    }\n\n    /**\n    * @notice Allows owner to change the treasury address. Treasury is the address where all funds from sale go to\n    * @param _treasury New treasury address\n    */\n    function adminSetTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n    }\n\n    /**\n    * @notice Allows owner to change min allowed token to buy per tx.\n    * @param _minToken New min token amount\n    */\n    function adminSetMinToken(uint256 _minToken) external onlyOwner {\n        minTokensAmount = _minToken;\n    }\n\n    /**\n    * @notice Allows owner to change max allowed token per address.\n    * @param _maxToken New max token amount\n    */\n    function adminSetMaxToken(uint256 _maxToken) external onlyOwner {\n        maxTokensAmount = _maxToken;\n    }\n\n    /**\n    * @notice Allows owner to change the max allowed gas price. Prevents gas wars\n    * @param _maxGasPrice New max gas price\n    */\n    function adminSetMaxGasPrice(uint256 _maxGasPrice) external onlyOwner {\n        maxGasPrice = _maxGasPrice;\n    }\n\n    /**\n    * @notice Sets a list of users who are allowed/denied to purchase\n    * @param _users A list of address\n    * @param _flag True to allow or false to disallow\n    */\n    function adminSetWhitelisted(address [] memory _users, bool _flag) external onlyOwner {\n        for (uint i = 0; i < _users.length; i++) {\n            whitelisted[_users[i]] = _flag;\n        }\n    }\n\n    /**\n    * @notice Stops purchase functions. Owner only\n    */\n    function adminPause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n    * @notice Unpauses purchase functions. Owner only\n    */\n    function adminUnpause() external onlyOwner {\n        _unpause();\n    }\n\n    function adminAddPurchase(address _receiver, uint256 _amount) virtual external onlyOwner {\n        purchased[_receiver] = purchased[_receiver].add(_amount);\n    }\n\n    /***\n     * PURCHASE FUNCTIONS\n     ***/\n\n    /**\n    * @notice For purchase with ETH\n    */\n    receive() external virtual payable onlySale whenNotPaused {\n        _purchaseTokenWithETH();\n    }\n\n    /**\n     * @notice For purchase with ETH. ETH is left on the contract until withdrawn to treasury\n     */\n    function purchaseTokenWithETH() external payable onlySale whenNotPaused {\n        _purchaseTokenWithETH();\n    }\n\n    function _purchaseTokenWithETH() private correctGas onlyWhitelist(_msgSender()) {\n        uint256 purchasedAmount = calcEthPurchasedAmount(msg.value);\n        require(purchasedAmount >= minTokensAmount, \"Minimum required unreached\");\n\n        purchasedPrivateSale = purchasedPrivateSale.add(purchasedAmount);\n        require(purchasedPrivateSale <= privateSaleTokenPool, \"Token is not enough!\");\n        purchased[_msgSender()] = purchased[_msgSender()].add(purchasedAmount);\n        require(purchased[_msgSender()] <= maxTokensAmount, \"Maximum allowed exceeded\");\n\n        emit TokenPurchased(_msgSender(), address(0), msg.value, purchasedAmount);\n    }\n\n    /**\n    * @notice For purchase with allowed stablecoin (USDC)\n    * @param coin Address of the token to be paid in\n    * @param amount Amount of the token to be paid in\n    */\n    function purchaseTokenWithCoin(address coin, uint256 amount) external onlySale whenNotPaused correctGas onlyWhitelist(_msgSender()) {\n        require(coin == USDC, \"Coin is not supported!\");\n        uint256 purchasedAmount = calcCoinPurchasedAmount(coin, amount);\n        require(purchasedAmount >= minTokensAmount, \"Minimum required unreached\");\n\n        purchasedPrivateSale = purchasedPrivateSale.add(purchasedAmount);\n        require(purchasedPrivateSale <= privateSaleTokenPool, \"Token is not enough!\");\n        purchased[_msgSender()] = purchased[_msgSender()].add(purchasedAmount);\n        require(purchased[_msgSender()] <= maxTokensAmount, \"Maximum allowed exceeded\");\n\n        IERC20(coin).safeTransferFrom(_msgSender(), address(this), amount);\n\n        emit TokenPurchased(_msgSender(), coin, amount, purchasedAmount);\n    }\n\n    /**\n     * @notice Function for the administrator to withdraw token\n     * @notice Withdrawals allowed only if there is no sale pending stage\n     * @param ERC20token Address of ERC20 token to withdraw from the contract\n     */\n    function adminWithdrawERC20(address ERC20token) external onlyOwner notOnSale {\n        uint256 withdrawAmount;\n        if (ERC20token != token) {\n            withdrawAmount = IERC20(ERC20token).balanceOf(address(this));\n        } else {\n            if (block.timestamp >= vestingStart.add(WITHDRAWAL_PERIOD)) {\n                withdrawAmount = IERC20(ERC20token).balanceOf(address(this));\n            } else {\n                withdrawAmount = IERC20(ERC20token).balanceOf(address(this)).sub(purchasedPrivateSale);\n            }\n        }\n\n        require(withdrawAmount > 0, \"No ERC20 to withdraw\");\n        IERC20(ERC20token).safeTransfer(treasury, withdrawAmount);\n    }\n\n    /**\n     * @notice Function for the administrator to withdraw ETH for refunds\n     * @notice Withdrawals allowed only if there is no sale pending stage\n     */\n    function adminWithdrawETH() external onlyOwner notOnSale {\n        require(address(this).balance > 0, \"No ETH to withdraw\");\n\n        (bool success,) = treasury.call{value : address(this).balance}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    /***\n     * VESTING INTERFACE\n     ***/\n\n    /**\n     * @notice Transfers available for claim vested tokens to the user.\n     */\n    function claim() external notOnSale {\n        require(vestingStart != 0, \"Vesting start is not set\");\n        uint256 unclaimed = claimable(_msgSender());\n        require(unclaimed > 0, \"TokenVesting: no tokens are due\");\n\n        _claimed[_msgSender()] = _claimed[_msgSender()].add(unclaimed);\n        IERC20(token).safeTransfer(_msgSender(), unclaimed);\n        emit TokensClaimed(_msgSender(), unclaimed);\n    }\n\n    /**\n     * @notice Gets the amount of tokens the user has already claimed\n     * @param _user Address of the user who purchased tokens\n     * @return The amount of the token claimed.\n     */\n    function claimed(address _user) external view returns (uint256) {\n        return _claimed[_user];\n    }\n\n    /**\n     * @notice Calculates the amount that has already vested but hasn't been claimed yet.\n     * @param _user Address of the user who purchased tokens\n     * @return The amount of the token vested and unclaimed.\n     */\n    function claimable(address _user) public view returns (uint256) {\n        return _vestedAmount(_user).sub(_claimed[_user]);\n    }\n\n    /**\n    * @notice Calculates the amount that is still locked.\n    * @param _user Address of the user who purchased tokens\n    * @return The amount of the token vested and unclaimed.\n    */\n    function locked(address _user) public view returns (uint256) {\n        return purchased[_user].sub(_vestedAmount(_user));\n    }\n\n    /**\n     * @dev Calculates the amount that has already vested.\n     * @param _user Address of the user who purchased tokens\n     * @return Amount of token already vested\n     */\n    function _vestedAmount(address _user) private view returns (uint256) {\n        if (vestingStart == 0 || block.timestamp < vestingStart) {\n            return 0;\n        } else if (block.timestamp >= vestingStart.add(vestingDuration)) {\n            return purchased[_user];\n        } else if (block.timestamp <= vestingStart.add(86400 * 4)) {\n            // first day,1%\n            return purchased[_user].div(100);\n        } else if (block.timestamp > vestingStart.add(86400 * 4) && block.timestamp <= vestingStart.add(86400 * 9)) {\n            // fifth day,3%\n            return purchased[_user].mul(4).div(100);\n        } else if (block.timestamp > vestingStart.add(86400 * 9) && block.timestamp <= vestingStart.add(86400 * 10)) {\n            // tenth day,6%\n            return purchased[_user].mul(10).div(100);\n        } else {\n            uint256 cliffAmount = purchased[_user].mul(10).div(100);\n            uint256 vestedAmount = purchased[_user].sub(cliffAmount).mul(block.timestamp.sub(vestingStart).sub(864000)).div(vestingDuration.sub(864000));\n            return cliffAmount.add(vestedAmount);\n        }\n    }\n\n    /**\n    * @dev Calculates token amount based on amount of eth.\n    * @param _amount Eth amount to convert to token\n    * @return purchasedAmount Token amount to buy\n    */\n    function calcEthPurchasedAmount(uint256 _amount) public view returns (uint256) {\n        if (address(priceFeed) != address(0)) {\n            uint decimals = priceFeed.decimals();\n            (,int256 price,,,) = priceFeed.latestRoundData();\n            return _amount.mul(uint256(price)).mul(PRECISION).div(tokenPrice).div(10 ** decimals);\n        } else {\n            return _amount.mul(basePrice).div(tokenPrice);\n        }\n    }\n\n    /**\n     * @dev Calculates token amount based on amount of token.\n     * @param _coin Supported ERC20 token\n     * @param _amount Coin amount to convert to token\n     * @return purchasedAmount Token amount to buy\n     */\n    function calcCoinPurchasedAmount(address _coin, uint256 _amount) public view returns (uint256) {\n        uint256 amountInUsd = _amount.mul(1e18).div(10 ** (uint256(ERC20(_coin).decimals())));\n        return amountInUsd.mul(PRECISION).div(tokenPrice);\n    }\n\n    /***\n     * INTERNAL HELPERS\n     ***/\n\n\n    /**\n     * @dev Checks if private-sale stage is on-going.\n     * @return True is private-sale is active\n     */\n    function _isPrivateSale() virtual internal view returns (bool) {\n        return (block.timestamp >= privateSaleStart && block.timestamp < privateSaleEnd);\n    }\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/StakingPoolInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract StakingPoolInitializable is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // The address of the smart chef factory\n    address public SMART_CHEF_FACTORY;\n\n    // Whether a limit is set for users\n    bool public hasUserLimit;\n\n    // Whether it is initialized\n    bool public isInitialized;\n\n    // Accrued token per share\n    uint256 public accTokenPerShare;\n\n    // The block number when EMO mining ends.\n    uint256 public bonusEndBlock;\n\n    // The block number when EMO mining starts.\n    uint256 public startBlock;\n\n    // The block number of the last pool update\n    uint256 public lastRewardBlock;\n\n    // The pool limit (0 if none)\n    uint256 public poolLimitPerUser;\n\n    // EMO tokens created per block.\n    uint256 public rewardPerBlock;\n\n    // The precision factor\n    uint256 public PRECISION_FACTOR;\n\n    // The reward token\n    IERC20 public rewardToken;\n\n    // The staked token\n    IERC20 public stakedToken;\n\n    // Info of each user that stakes tokens (stakedToken)\n    mapping(address => UserInfo) public userInfo;\n\n    struct UserInfo {\n        uint256 amount; // How many staked tokens the user has provided\n        uint256 rewardDebt; // Reward debt\n    }\n\n    event AdminTokenRecovery(address tokenRecovered, uint256 amount);\n    event Deposit(address indexed user, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 amount);\n    event NewStartAndEndBlocks(uint256 startBlock, uint256 endBlock);\n    event NewRewardPerBlock(uint256 rewardPerBlock);\n    event NewPoolLimit(uint256 poolLimitPerUser);\n    event RewardsStop(uint256 blockNumber);\n    event Withdraw(address indexed user, uint256 amount);\n\n    constructor() public {\n        SMART_CHEF_FACTORY = msg.sender;\n    }\n\n    /*\n     * @notice Initialize the contract\n     * @param _stakedToken: staked token address\n     * @param _rewardToken: reward token address\n     * @param _rewardPerBlock: reward per block (in rewardToken)\n     * @param _startBlock: start block\n     * @param _bonusEndBlock: end block\n     * @param _poolLimitPerUser: pool limit per user in stakedToken (if any, else 0)\n     * @param _admin: admin address with ownership\n     */\n    function initialize(\n        IERC20 _stakedToken,\n        IERC20 _rewardToken,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _bonusEndBlock,\n        uint256 _poolLimitPerUser,\n        address _admin\n    ) external {\n        require(!isInitialized, \"Already initialized\");\n        require(msg.sender == SMART_CHEF_FACTORY, \"Not factory\");\n\n        // Make this contract initialized\n        isInitialized = true;\n\n        stakedToken = _stakedToken;\n        rewardToken = _rewardToken;\n        rewardPerBlock = _rewardPerBlock;\n        startBlock = _startBlock;\n        bonusEndBlock = _bonusEndBlock;\n\n        if (_poolLimitPerUser > 0) {\n            hasUserLimit = true;\n            poolLimitPerUser = _poolLimitPerUser;\n        }\n\n        uint256 decimalsRewardToken = uint256(ERC20(address(rewardToken)).decimals());\n        require(decimalsRewardToken < 30, \"Must be inferior to 30\");\n\n        PRECISION_FACTOR = uint256(10**(uint256(30).sub(decimalsRewardToken)));\n\n        // Set the lastRewardBlock as the startBlock\n        lastRewardBlock = startBlock;\n\n        // Transfer ownership to the admin address who becomes owner of the contract\n        transferOwnership(_admin);\n    }\n\n    /*\n     * @notice Deposit staked tokens and collect reward tokens (if any)\n     * @param _amount: amount to withdraw (in rewardToken)\n     */\n    function deposit(uint256 _amount) external nonReentrant {\n        UserInfo storage user = userInfo[msg.sender];\n\n        if (hasUserLimit) {\n            require(_amount.add(user.amount) <= poolLimitPerUser, \"User amount above limit\");\n        }\n\n        _updatePool();\n\n        if (user.amount > 0) {\n            uint256 pending = user.amount.mul(accTokenPerShare).div(PRECISION_FACTOR).sub(user.rewardDebt);\n            if (pending > 0) {\n                rewardToken.safeTransfer(address(msg.sender), pending);\n            }\n        }\n\n        if (_amount > 0) {\n            user.amount = user.amount.add(_amount);\n            stakedToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        }\n\n        user.rewardDebt = user.amount.mul(accTokenPerShare).div(PRECISION_FACTOR);\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /*\n     * @notice Withdraw staked tokens and collect reward tokens\n     * @param _amount: amount to withdraw (in rewardToken)\n     */\n    function withdraw(uint256 _amount) external nonReentrant {\n        UserInfo storage user = userInfo[msg.sender];\n        require(user.amount >= _amount, \"Amount to withdraw too high\");\n\n        _updatePool();\n\n        uint256 pending = user.amount.mul(accTokenPerShare).div(PRECISION_FACTOR).sub(user.rewardDebt);\n\n        if (_amount > 0) {\n            user.amount = user.amount.sub(_amount);\n            stakedToken.safeTransfer(address(msg.sender), _amount);\n        }\n\n        if (pending > 0) {\n            rewardToken.safeTransfer(address(msg.sender), pending);\n        }\n\n        user.rewardDebt = user.amount.mul(accTokenPerShare).div(PRECISION_FACTOR);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /*\n     * @notice Withdraw staked tokens without caring about rewards rewards\n     * @dev Needs to be for emergency.\n     */\n    function emergencyWithdraw() external nonReentrant {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 amountToTransfer = user.amount;\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        if (amountToTransfer > 0) {\n            stakedToken.safeTransfer(address(msg.sender), amountToTransfer);\n        }\n\n        emit EmergencyWithdraw(msg.sender, user.amount);\n    }\n\n    /*\n     * @notice Stop rewards\n     * @dev Only callable by owner. Needs to be for emergency.\n     */\n    function emergencyRewardWithdraw(uint256 _amount) external onlyOwner {\n        rewardToken.safeTransfer(address(msg.sender), _amount);\n    }\n\n    /**\n     * @notice It allows the admin to recover wrong tokens sent to the contract\n     * @param _tokenAddress: the address of the token to withdraw\n     * @param _tokenAmount: the number of tokens to withdraw\n     * @dev This function is only callable by admin.\n     */\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(stakedToken), \"Cannot be staked token\");\n        require(_tokenAddress != address(rewardToken), \"Cannot be reward token\");\n\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\n\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\n    }\n\n    /*\n     * @notice Stop rewards\n     * @dev Only callable by owner\n     */\n    function stopReward() external onlyOwner {\n        bonusEndBlock = block.number;\n    }\n\n    /*\n     * @notice Update pool limit per user\n     * @dev Only callable by owner.\n     * @param _hasUserLimit: whether the limit remains forced\n     * @param _poolLimitPerUser: new pool limit per user\n     */\n    function updatePoolLimitPerUser(bool _hasUserLimit, uint256 _poolLimitPerUser) external onlyOwner {\n        require(hasUserLimit, \"Must be set\");\n        if (_hasUserLimit) {\n            require(_poolLimitPerUser > poolLimitPerUser, \"New limit must be higher\");\n            poolLimitPerUser = _poolLimitPerUser;\n        } else {\n            hasUserLimit = _hasUserLimit;\n            poolLimitPerUser = 0;\n        }\n        emit NewPoolLimit(poolLimitPerUser);\n    }\n\n    /*\n     * @notice Update reward per block\n     * @dev Only callable by owner.\n     * @param _rewardPerBlock: the reward per block\n     */\n    function updateRewardPerBlock(uint256 _rewardPerBlock) external onlyOwner {\n        require(block.number < startBlock, \"Pool has started\");\n        rewardPerBlock = _rewardPerBlock;\n        emit NewRewardPerBlock(_rewardPerBlock);\n    }\n\n    /**\n     * @notice It allows the admin to update start and end blocks\n     * @dev This function is only callable by owner.\n     * @param _startBlock: the new start block\n     * @param _bonusEndBlock: the new end block\n     */\n    function updateStartAndEndBlocks(uint256 _startBlock, uint256 _bonusEndBlock) external onlyOwner {\n        require(block.number < startBlock, \"Pool has started\");\n        require(_startBlock < _bonusEndBlock, \"New startBlock must be lower than new endBlock\");\n        require(block.number < _startBlock, \"New startBlock must be higher than current block\");\n\n        startBlock = _startBlock;\n        bonusEndBlock = _bonusEndBlock;\n\n        // Set the lastRewardBlock as the startBlock\n        lastRewardBlock = startBlock;\n\n        emit NewStartAndEndBlocks(_startBlock, _bonusEndBlock);\n    }\n\n    /*\n     * @notice View function to see pending reward on frontend.\n     * @param _user: user address\n     * @return Pending reward for a given user\n     */\n    function pendingReward(address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        uint256 stakedTokenSupply = stakedToken.balanceOf(address(this));\n        if (block.number > lastRewardBlock && stakedTokenSupply != 0) {\n            uint256 multiplier = _getMultiplier(lastRewardBlock, block.number);\n            uint256 emoReward = multiplier.mul(rewardPerBlock);\n            uint256 adjustedTokenPerShare =\n            accTokenPerShare.add(emoReward.mul(PRECISION_FACTOR).div(stakedTokenSupply));\n            return user.amount.mul(adjustedTokenPerShare).div(PRECISION_FACTOR).sub(user.rewardDebt);\n        } else {\n            return user.amount.mul(accTokenPerShare).div(PRECISION_FACTOR).sub(user.rewardDebt);\n        }\n    }\n\n    /*\n     * @notice Update reward variables of the given pool to be up-to-date.\n     */\n    function _updatePool() internal {\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n\n        uint256 stakedTokenSupply = stakedToken.balanceOf(address(this));\n\n        if (stakedTokenSupply == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n\n        uint256 multiplier = _getMultiplier(lastRewardBlock, block.number);\n        uint256 emoReward = multiplier.mul(rewardPerBlock);\n        accTokenPerShare = accTokenPerShare.add(emoReward.mul(PRECISION_FACTOR).div(stakedTokenSupply));\n        lastRewardBlock = block.number;\n    }\n\n    /*\n     * @notice Return reward multiplier over the given _from to _to block.\n     * @param _from: block to start\n     * @param _to: block to finish\n     */\n    function _getMultiplier(uint256 _from, uint256 _to) internal view returns (uint256) {\n        if (_to <= bonusEndBlock) {\n            return _to.sub(_from);\n        } else if (_from >= bonusEndBlock) {\n            return 0;\n        } else {\n            return bonusEndBlock.sub(_from);\n        }\n    }\n}"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/staking/VotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../interfaces/IRewardPool.sol\";\nimport \"../interfaces/IMasterChef.sol\";\n\ncontract VotingEscrow is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    enum ActionType {DEPOSIT_FOR, CREATE_LOCK, INCREASE_LOCK_AMOUNT, INCREASE_UNLOCK_TIME}\n\n    uint256 public constant WEEK = 7 * 86400;\n    uint256 public constant MAXTIME = 4 * 365 * 86400;  // 4 years\n    uint256 public constant MULTIPLIER = 1e18;\n\n    struct Point {\n        int128 bias;\n        int128 slope;   // - dweight / dt\n        uint256 ts;\n        uint256 blk;    // block\n    }\n\n    struct LockedBalance {\n        int128 amount;\n        uint256 end;\n    }\n\n    string public name;\n    string public symbol;\n    string public version;\n    uint8 public immutable decimals;\n\n    address public token;\n    IRewardPool public rewardPool;\n    uint256 public supply; // total amount of emo token\n\n    IMasterChef public masterchef;\n\n    mapping(address => LockedBalance) public locked;\n\n    bool public emergency;\n\n    uint256 public epoch;\n    Point[100000000000000000000000000000] public pointHistory; // epoch -> point\n    mapping(address => Point[1000000000]) public userPointHistory; // user -> Point[user_epoch]\n    mapping(address => uint256) public userPointEpoch;\n    mapping(uint256 => int128) public slopeChanges; // time -> slope change\n\n    mapping(address => bool) public whitelist; // Only EOA or contract whitelisted is allowed to deposit\n\n    event Deposit(address indexed provider, uint256 indexed locktime, uint256 value, uint actionType, uint256 ts);\n    event Withdraw(address indexed provider, uint256 value, uint256 ts);\n    event Supply(uint256 prevSupply, uint256 supply);\n    event Error(bytes error);\n\n    modifier onlyEoaOrWhitelist(address addr) {\n        require(tx.origin == msg.sender || whitelist[addr], \"Contract is not in the whitelist\");\n        _;\n    }\n\n    modifier notEmergency() {\n        require(!emergency, \"In an emergency\");\n        _;\n    }\n\n    constructor(address _token, string memory _name, string memory _symbol, string memory _version) public {\n        token = _token;\n        pointHistory[0].blk = block.number;\n        pointHistory[0].ts = block.timestamp;\n\n        decimals = ERC20(_token).decimals();\n        name = _name;\n        symbol = _symbol;\n        version = _version;\n    }\n\n    /**\n    * @notice Sets a list of users who are allowed/denied to deposit\n    * @param _users A list of address\n    * @param _flag True to allow or false to disallow\n    */\n    function setWhitelist(address [] memory _users, bool _flag) external onlyOwner {\n        for (uint i = 0; i < _users.length; i++) {\n            whitelist[_users[i]] = _flag;\n        }\n    }\n\n    /**\n    * @notice Only set once\n    * @param _rewardPool Address of reward pool\n    */\n    function setRewardPool(IRewardPool _rewardPool) external onlyOwner {\n        require(address(rewardPool) == address(0), \"RewardPool has been set\");\n        rewardPool = _rewardPool;\n        IERC20(token).approve(address(_rewardPool), uint256(~0));\n    }\n\n    /**\n    * @notice Only set once\n    * @param _masterchef Address of masterchef\n    */\n    function setMasterchef(IMasterChef _masterchef) external onlyOwner {\n        masterchef = _masterchef;\n    }\n\n    /**\n    * @notice Only set once\n    */\n    function setEmergency() external onlyOwner {\n        emergency = true;\n    }\n\n    /**\n    * @notice Get the most recently recorded rate of voting power decrease for `addr`\n    * @param addr Address of the user wallet\n    * @return Value of the slope\n    **/\n    function getLastUserSlope(address addr) external view returns (int128) {\n        uint256 uepoch = userPointEpoch[addr];\n        return userPointHistory[addr][uepoch].slope;\n    }\n\n    /**\n    * @notice Get the timestamp for checkpoint `_idx` for `_addr`\n    * @param _addr User wallet address\n    * @param _idx User epoch number\n    * @return Epoch time of the checkpoint\n    **/\n    function userPointHistoryTs(address _addr, uint256 _idx) external view returns (uint256) {\n        return userPointHistory[_addr][_idx].ts;\n    }\n\n    /**\n    * @notice Get timestamp when `_addr`'s lock finishes\n    * @param _addr User wallet\n    * @return Epoch time of the lock end\n    **/\n    function lockedEnd(address _addr) external view returns (uint256) {\n        return locked[_addr].end;\n    }\n\n    /**\n    * @notice Record global and per-user data to checkpoint\n    * @param addr User's wallet address. No user checkpoint if 0x0\n    * @param oldLocked Pevious locked amount / end lock time for the user\n    * @param newLocked New locked amount / end lock time for the user\n    **/\n    function _checkpoint(address addr, LockedBalance memory oldLocked, LockedBalance memory newLocked) internal {\n        Point memory uOld;\n        Point memory uNew;\n        int128 oldDslope = 0;\n        int128 newDslope = 0;\n        uint256 _epoch = epoch;\n\n        if (addr != address(0)) {\n            if (oldLocked.end > block.timestamp && oldLocked.amount > 0) {\n                uOld.slope = oldLocked.amount / int128(MAXTIME);\n                uOld.bias = uOld.slope * (int128(oldLocked.end - block.timestamp));\n            }\n            if (newLocked.end > block.timestamp && newLocked.amount > 0) {\n                uNew.slope = newLocked.amount / int128(MAXTIME);\n                uNew.bias = uNew.slope * (int128(newLocked.end - block.timestamp));\n            }\n\n            oldDslope = slopeChanges[oldLocked.end];\n            if (newLocked.end != 0) {\n                if (newLocked.end == oldLocked.end) {\n                    newDslope = oldDslope;\n                } else {\n                    newDslope = slopeChanges[newLocked.end];\n                }\n            }\n        }\n\n        Point memory lastPoint = Point({bias : 0, slope : 0, ts : block.timestamp, blk : block.number});\n        if (_epoch > 0) {\n            lastPoint = pointHistory[_epoch];\n        }\n        uint256 lastCheckpoint = lastPoint.ts;\n\n        Point memory initialLastPoint = Point({bias : lastPoint.bias, slope : lastPoint.slope, ts : lastPoint.ts, blk : lastPoint.blk});\n        // dblock/dt\n        uint256 blockSlope = 0;\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope = MULTIPLIER * (block.number - lastPoint.blk) / (block.timestamp - lastPoint.ts);\n        }\n\n        // Go over weeks to fill history and calculate what the current point is\n        uint256 t_i = (lastCheckpoint / WEEK) * WEEK;\n        for (uint i; i < 255; i++) {\n            t_i += WEEK;\n            int128 dSlope = 0;\n            if (t_i > block.timestamp) {\n                t_i = block.timestamp;\n            } else {\n                dSlope = slopeChanges[t_i];\n            }\n            lastPoint.bias -= (lastPoint.slope * (int128(t_i - lastCheckpoint)));\n            lastPoint.slope += dSlope;\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            // It will never happen,just in case\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            lastCheckpoint = t_i;\n            lastPoint.ts = t_i;\n            lastPoint.blk = initialLastPoint.blk.add(blockSlope.mul(t_i.sub(initialLastPoint.ts)).div(MULTIPLIER));\n            _epoch += 1;\n            if (t_i == block.timestamp) {\n                lastPoint.blk = block.number;\n                break;\n            } else {\n                pointHistory[_epoch] = lastPoint;\n            }\n        }\n\n        epoch = _epoch;\n\n        if (addr != address(0)) {\n            // If last point was in this block, the slope change has been applied already\n            lastPoint.slope += (uNew.slope - uOld.slope);\n            lastPoint.bias += (uNew.bias - uOld.bias);\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n        }\n\n        // Record the changed point into history\n        pointHistory[_epoch] = lastPoint;\n\n        // avoid stack too deep\n        address _addr = addr;\n        if (_addr != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [newLocked.end]\n            // and add old_user_slope to [oldLocked.end]\n            if (oldLocked.end > block.timestamp) {\n                oldDslope += uOld.slope;\n                if (newLocked.end == oldLocked.end) {\n                    oldDslope -= uNew.slope;\n                }\n                slopeChanges[oldLocked.end] = oldDslope;\n            }\n\n            if (newLocked.end > block.timestamp) {\n                if (newLocked.end > oldLocked.end) {\n                    // old slope disappeared at this point\n                    newDslope -= uNew.slope;\n                    slopeChanges[newLocked.end] = newDslope;\n                }\n            }\n\n            // Now handle user history\n            uint256 userEpoch = userPointEpoch[_addr] + 1;\n\n            userPointEpoch[_addr] = userEpoch;\n            uNew.ts = block.timestamp;\n            uNew.blk = block.number;\n            userPointHistory[_addr][userEpoch] = uNew;\n        }\n    }\n\n    /**\n    * @notice Deposit and lock tokens for a user\n    * @param _addr User's wallet address\n    * @param _value Amount to deposit\n    * @param unlockTime New time when to unlock the tokens, or 0 if unchanged\n    * @param lockedBalance Previous locked amount / timestamp\n    **/\n    function _depositFor(address _addr, uint256 _value, uint256 unlockTime, LockedBalance memory lockedBalance, ActionType actionType) internal {\n        LockedBalance memory _locked = lockedBalance;\n        uint256 supplyBefore = supply;\n\n        supply = supplyBefore.add(_value);\n        LockedBalance memory oldLocked = LockedBalance({amount : _locked.amount, end : _locked.end});\n        _locked.amount += int128(_value);\n        if (unlockTime != 0) {\n            _locked.end = unlockTime;\n        }\n        locked[_addr] = _locked;\n\n        // Possibilities:\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // _locked.end > block.timestamp (always)\n        _checkpoint(_addr, oldLocked, _locked);\n\n        if (_value != 0) {\n            require(ERC20(token).transferFrom(_addr, address(this), _value), \"Transfer failed!\");\n            require(rewardPool.depositFor(_addr, _value), \"Deposit into reward pool failed.\");\n        }\n\n        emit Deposit(_addr, _locked.end, _value, uint(actionType), block.timestamp);\n        emit Supply(supplyBefore, supplyBefore + _value);\n    }\n\n    /**\n    * @notice Record global data to checkpoint\n    **/\n    function checkpoint() external notEmergency {\n        _checkpoint(address(0), LockedBalance({amount : 0, end : 0}), LockedBalance({amount : 0, end : 0}));\n    }\n\n    /**\n    * @notice Deposit `_value` tokens for `_addr` and add to the lock\n    * @dev Anyone (even a smart contract) can deposit for someone else, but\n    * cannot extend their locktime and deposit for a brand new user\n    * @param _addr User's wallet address\n    * @param _value Amount to add to user's lock\n    **/\n    function depositFor(address _addr, uint256 _value) public nonReentrant notEmergency {\n        require(_value > 0, \"Need non-zero value\");\n        LockedBalance memory _locked = locked[_addr];\n        require(_locked.amount > 0, \"No existing lock found\");\n        require(_locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\");\n\n        _depositFor(_addr, _value, 0, _locked, ActionType.DEPOSIT_FOR);\n    }\n\n    function depositForWithMc(address _addr, uint256 _value) external {\n        depositFor(_addr, _value);\n        masterchef.harvestAllRewards(_addr);\n    }\n\n    /**\n    * @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\n    * @param _value Amount to deposit\n    * @param _unlockTime Epoch time when tokens unlock, rounded down to whole weeks\n    **/\n    function createLock(uint256 _value, uint256 _unlockTime) public nonReentrant notEmergency onlyEoaOrWhitelist(msg.sender) {\n        require(_value > 0, \"Need non-zero value\");\n\n        // Locktime is rounded down to weeks\n        uint256 unlockTime = (_unlockTime / WEEK) * WEEK;\n        LockedBalance memory _locked = locked[msg.sender];\n        require(_locked.amount == 0, \"Withdraw old tokens first\");\n        require(unlockTime > block.timestamp, \"Can only lock until time in the future\");\n        require(unlockTime <= block.timestamp + MAXTIME, \"Voting lock can be 4 years max\");\n\n        _depositFor(msg.sender, _value, unlockTime, _locked, ActionType.CREATE_LOCK);\n    }\n\n    function createLockWithMc(uint256 _value, uint256 _unlockTime) external {\n        createLock(_value, _unlockTime);\n        masterchef.harvestAllRewards(msg.sender);\n    }\n\n    /**\n    * @notice Deposit `_value` additional tokens for `msg.sender`\n    * without modifying the unlock time\n    * @param _value Amount of tokens to deposit and add to the lock\n    **/\n    function increaseAmount(uint256 _value) public nonReentrant notEmergency onlyEoaOrWhitelist(msg.sender) {\n        require(_value > 0, \"Need non-zero value\");\n        LockedBalance memory _locked = locked[msg.sender];\n        require(_locked.amount > 0, \"No existing lock found\");\n        require(_locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\");\n\n        _depositFor(msg.sender, _value, 0, _locked, ActionType.INCREASE_LOCK_AMOUNT);\n    }\n\n    function increaseAmountWithMc(uint256 _value) external {\n        increaseAmount(_value);\n        masterchef.harvestAllRewards(msg.sender);\n    }\n\n    /**\n    * @notice Extend the unlock time for `msg.sender` to `_unlock_time`\n    * @param _unlockTime New epoch time for unlocking\n    **/\n    function increaseUnlockTime(uint256 _unlockTime) public nonReentrant notEmergency onlyEoaOrWhitelist(msg.sender) {\n        LockedBalance memory _locked = locked[msg.sender];\n        uint256 unlockTime = (_unlockTime / WEEK) * WEEK;\n\n        require(_locked.end > block.timestamp, \"Lock expired\");\n        require(_locked.amount > 0, \"Nothing is locked\");\n        require(unlockTime > _locked.end, \"Can only increase lock duration\");\n        require(unlockTime <= block.timestamp + MAXTIME, \"Voting lock can be 4 years max\");\n\n        _depositFor(msg.sender, 0, unlockTime, _locked, ActionType.INCREASE_UNLOCK_TIME);\n    }\n\n    function increaseUnlockTimeWithMc(uint256 _unlockTime) external {\n        increaseUnlockTime(_unlockTime);\n        masterchef.harvestAllRewards(msg.sender);\n    }\n\n    /**\n    * @notice Withdraw all tokens for `msg.sender`\n    * @dev Only possible if the lock has expired\n    **/\n    function withdraw() public nonReentrant notEmergency {\n        LockedBalance memory _locked = locked[msg.sender];\n        require(block.timestamp >= _locked.end, \"The lock didn't expire\");\n\n        uint256 value = uint256(_locked.amount);\n        LockedBalance memory oldLocked = locked[msg.sender];\n        _locked.end = 0;\n        _locked.amount = 0;\n        locked[msg.sender] = _locked;\n\n        uint256 supplyBefore = supply;\n        supply = supplyBefore.sub(value);\n\n        // oldLocked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, oldLocked, _locked);\n        require(rewardPool.withdrawFor(msg.sender, value), \"Withdraw from reward pool failed.\");\n        require(ERC20(token).transfer(msg.sender, value), \"Transfer failed!\");\n\n        emit Withdraw(msg.sender, value, block.timestamp);\n        emit Supply(supplyBefore, supplyBefore - value);\n    }\n\n    /**\n    * @notice Withdraw during emergency\n    **/\n    function emergencyWithdraw() external {\n        require(emergency, \"Only can be called in an emergency\");\n\n        LockedBalance storage _locked = locked[msg.sender];\n        uint256 value = uint256(_locked.amount);\n        try rewardPool.emergencyWithdraw(msg.sender) {\n        } catch (bytes memory error) {\n            emit Error(error);\n        }\n\n        _locked.end = 0;\n        _locked.amount = 0;\n        if (supply >= value) {\n            supply = supply - value;\n        } else {\n            supply = 0;\n        }\n        ERC20(token).transfer(msg.sender, value);\n    }\n\n    function withdrawWithMc() external {\n        withdraw();\n        masterchef.harvestAllRewards(msg.sender);\n    }\n\n    /**\n    * The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    * They measure the weights for the purpose of voting, so they don't represent\n    * real coins.\n    **/\n\n    /**\n    * @notice Binary search to estimate timestamp for block number\n    * @param _block Block to find\n    * @param maxEpoch Don't go beyond this epoch\n    * @return Approximate timestamp for block\n    **/\n    function findBlockEpoch(uint256 _block, uint256 maxEpoch) internal view returns (uint256){\n        // binary search\n        uint256 _min = 0;\n        uint256 _max = maxEpoch;\n        for (uint i; i < 128; i++) {\n            if (_min >= _max) {\n                break;\n            }\n            uint256 _mid = (_min + _max + 1) / 2;\n            if (pointHistory[_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    /**\n    * @notice Get the voting power for `msg.sender`\n    * @param addr User wallet address\n    * @param _t Epoch time to return voting power at\n    * @return User voting power\n    **/\n    function balanceOfT(address addr, uint256 _t) public view returns (uint256) {\n        uint256 _epoch = userPointEpoch[addr];\n        if (_epoch == 0) {\n            return 0;\n        } else {\n            Point memory lastPoint = userPointHistory[addr][_epoch];\n            lastPoint.bias -= lastPoint.slope * (int128(_t - lastPoint.ts));\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            return uint256(lastPoint.bias);\n        }\n    }\n\n    /**\n    * @notice Get the current voting power for `msg.sender`\n    * @param addr User wallet address\n    * @return User voting power\n    **/\n    function balanceOf(address addr) external view returns (uint256) {\n        return balanceOfT(addr, block.timestamp);\n    }\n\n    /**\n    * @notice Measure voting power of `addr` at block height `_block`\n    * @param addr User's wallet address\n    * @param _block Block to calculate the voting power at\n    * @return Voting power\n    **/\n    function balanceOfB(address addr, uint256 _block) external view returns (uint256) {\n        require(_block <= block.number, \"Block should not be greater than current block!\");\n\n        uint256 _min = 0;\n        uint256 _max = userPointEpoch[addr];\n        for (uint i; i < 128; i++) {\n            if (_min >= _max) {\n                break;\n            }\n            uint256 _mid = (_min + _max + 1) / 2;\n            if (userPointHistory[addr][_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n\n        Point memory upoint = userPointHistory[addr][_min];\n\n        uint256 maxEpoch = epoch;\n        uint256 _epoch = findBlockEpoch(_block, maxEpoch);\n        Point memory point0 = pointHistory[_epoch];\n        uint256 dBlock = 0;\n        uint256 dT = 0;\n        if (_epoch < maxEpoch) {\n            Point memory point1 = pointHistory[_epoch + 1];\n            dBlock = point1.blk.sub(point0.blk);\n            dT = point1.ts.sub(point0.ts);\n        } else {\n            dBlock = block.number.sub(point0.blk);\n            dT = block.timestamp.sub(point0.ts);\n        }\n        uint256 blockTime = point0.ts;\n        if (dBlock != 0) {\n            blockTime += dT * (_block.sub(point0.blk)) / dBlock;\n        }\n\n        upoint.bias -= upoint.slope * int128(blockTime - upoint.ts);\n        if (upoint.bias >= 0) {\n            return uint256(upoint.bias);\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n    * @notice Calculate total voting power at some point in the past\n    * @param point The point (bias/slope) to start search from\n    * @param t Time to calculate the total voting power at\n    * @return Total voting power at that time\n    **/\n    function supplyAt(Point memory point, uint256 t) internal view returns (uint256) {\n        Point memory lastPoint = point;\n        uint256 t_i = (lastPoint.ts / WEEK) * WEEK;\n        for (uint i; i < 255; i++) {\n            t_i += WEEK;\n            int128 dSlope = 0;\n            if (t_i > t) {\n                t_i = t;\n            } else {\n                dSlope = slopeChanges[t_i];\n            }\n            lastPoint.bias -= lastPoint.slope * int128(t_i - lastPoint.ts);\n            if (t_i == t) {\n                break;\n            }\n            lastPoint.slope += dSlope;\n            lastPoint.ts = t_i;\n        }\n\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(lastPoint.bias);\n    }\n\n    /**\n    * @notice Calculate total voting power\n    * @param t Time to calculate the total voting power at\n    * @return Total voting power\n    **/\n    function totalSupplyT(uint256 t) public view returns (uint256) {\n        Point memory lastPoint = pointHistory[epoch];\n        return supplyAt(lastPoint, t);\n    }\n\n    /**\n    * @notice Calculate current total voting power\n    * @return Total voting power\n    **/\n    function totalSupply() external view returns (uint256) {\n        return totalSupplyT(block.timestamp);\n    }\n\n    /**\n    * @notice Calculate total voting power at some point in the past\n    * @param _block Block to calculate the total voting power at\n    * @return Total voting power at `_block`\n    **/\n    function totalSupplyB(uint256 _block) external view returns (uint256) {\n        require(_block <= block.number, \"Block should not be greater than current block!\");\n        uint256 _epoch = epoch;\n        uint256 targetEpoch = findBlockEpoch(_block, _epoch);\n\n        Point memory point = pointHistory[targetEpoch];\n        uint256 dt = 0;\n        if (targetEpoch < _epoch) {\n            Point memory nextPoint = pointHistory[targetEpoch + 1];\n            if (point.blk != nextPoint.blk) {\n                dt = (_block - point.blk) * (nextPoint.ts - point.ts) / (nextPoint.blk - point.blk);\n            }\n        } else {\n            if (point.blk != block.number) {\n                dt = (_block - point.blk) * (block.timestamp - point.ts) / (block.number - point.blk);\n            }\n        }\n\n        // Now dt contains info on how far are we beyond point\n        return supplyAt(point, point.ts + dt);\n    }\n}"
    },
    "contracts/interfaces/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IRewardPool {\n    function depositFor(address _user, uint256 _amount) external returns(bool);\n\n    function withdrawFor(address _user, uint256 _principals) external returns(bool);\n\n    function emergencyWithdraw(address _user) external;\n}\n"
    },
    "contracts/interfaces/IMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IOnwardIncentivesController.sol\";\n\ninterface IMasterChef {\n    function owner() external view returns (address);\n\n    function emo() external view returns (address);\n\n    function startTime() external view returns (uint256);\n\n    function emoPerSecond() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n\n    function totalAllocPoint() external view returns (uint256);\n\n    function TOKENLESS_PRODUCTION() external view returns (uint256);\n\n    function poolInfo(uint _pid) external view returns (\n        address lpToken,\n        uint256 workingSupply,\n        bool boost,\n        uint256 allocPoint,\n        uint256 lastRewardTime,\n        uint256 accEmoPerShare,\n        address incentivesController);\n\n    function userInfo(uint _pid, address _user) external view returns (\n        uint256 amount,\n        uint256 workingAmount,\n        uint256 rewardDebt);\n\n    // emo + bonus reward\n    function pendingTokens(uint256 _pid, address _user) external view returns (address[] memory tokens, uint[] memory amounts);\n\n    // Transfers ownership of the contract to a new account (`newOwner`)\n    function transferOwnership(address newOwner) external;\n\n    // Add a new lp to the pool. Can only be called by the owner.\n    function add(uint256 _allocPoint, IERC20 _lpToken, IOnwardIncentivesController _incentivesController, bool _boost, bool _withUpdate) external;\n\n    // Update the given pool's EMO allocation point. Can only be called by the owner.\n    function set(uint256 _pid, uint256 _allocPoint, IOnwardIncentivesController _incentivesController, bool _withUpdate) external;\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) external;\n\n    // Stake EMO tokens to MasterChef\n    function enterStaking(uint256 _amount) external;\n\n    // Withdraw EMO tokens from STAKING.\n    function leaveStaking(uint256 _amount) external;\n\n    // Deposit LP tokens to MasterChef for EMO allocation.\n    function depositFor(address _user, uint256 _pid, uint256 _amount) external;\n\n    // Deposit LP tokens to MasterChef for EMO allocation.\n    function deposit(uint _pid, uint _amount) external;\n\n    // Withdraw LP tokens from MasterChef.\n    function withdraw(uint _pid, uint _amount) external;\n\n    function harvestAllRewards(address _user) external;\n\n    function emergencyWithdraw(uint256 _pid) external;\n\n    function setEmoPerSecond(uint256 _emoPerSecond) external;\n}"
    },
    "contracts/interfaces/IOnwardIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IOnwardIncentivesController {\n    function onReward(address user, uint256 newLpAmount) external;\n\n    function pendingTokens(address user) external view returns (uint256 pending);\n\n    function rewardToken() external view returns (IERC20);\n\n    function getNextIncentivesController() external view returns (address);\n}\n"
    },
    "contracts/tools/Dashboard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../libraries/SafeDecimal.sol\";\nimport \"../interfaces/IMasterChef.sol\";\nimport \"../interfaces/IEvmoSwapPair.sol\";\nimport \"../interfaces/IEvmoSwapFactory.sol\";\n\ncontract Dashboard {\n    using SafeMath for uint;\n    using SafeDecimal for uint;\n\n    uint256 private constant SEC_PER_YEAR = 86400 * 365;\n\n    address private _owner;\n\n    // WETH WFTM WBNB\n    IERC20 public weth;\n    IERC20 public usdc;\n    IMasterChef public master;\n    IEvmoSwapFactory public factory;\n    IERC20 public reward; \n\n    mapping(address => address) public pairAddresses;\n\n    constructor(address _weth, address _usdc, address _reward, address _master, address _factory) public {\n        weth = IERC20(_weth);\n        usdc = IERC20(_usdc);\n        reward = IERC20(_reward);\n        master = IMasterChef(_master);\n        factory = IEvmoSwapFactory(_factory);\n        _owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /* ========== Restricted Operation ========== */\n\n    function setPairAddress(address asset, address pair) external onlyOwner {\n        pairAddresses[asset] = pair;\n    }\n\n    /* ========== Value Calculation ========== */\n\n    function ethPriceInUSD() view public returns (uint) {\n        address usdcEthPair = factory.getPair(address(usdc), address(weth));\n        uint _decimals = ERC20(address(usdc)).decimals();\n        uint _usdcValue = usdc.balanceOf(usdcEthPair).mul(10 ** (18 - uint256(_decimals)));\n        return _usdcValue.mul(1e18).div(weth.balanceOf(usdcEthPair));\n    }\n\n    function rewardPriceInUSD() view public returns (uint) {\n        (, uint _rewardPriceInUSD) = valueOfAsset(address(reward), 1e18);\n        return _rewardPriceInUSD;\n    }\n\n    function rewardPerYearOfPool(uint pid) view public returns (uint) {\n        uint256 multiplier = master.startTime() <= block.timestamp ? 1 : 0;\n        (,,,uint allocPoint,,,) = master.poolInfo(pid);\n        return master.emoPerSecond().mul(multiplier).mul(SEC_PER_YEAR).mul(allocPoint).div(master.totalAllocPoint());\n    }\n\n    function valueOfAsset(address asset, uint amount) public view returns (uint valueInETH, uint valueInUSD) {\n        if (asset == address(0) || asset == address(weth)) {\n            valueInETH = amount;\n            valueInUSD = amount.mul(ethPriceInUSD()).div(1e18);\n        } else if (keccak256(abi.encodePacked(IEvmoSwapPair(asset).symbol())) == keccak256(\"EMO-LP\")) {\n            if (IEvmoSwapPair(asset).token0() == address(weth) || IEvmoSwapPair(asset).token1() == address(weth)) {\n                valueInETH = amount.mul(weth.balanceOf(address(asset))).mul(2).div(IEvmoSwapPair(asset).totalSupply());\n                valueInUSD = valueInETH.mul(ethPriceInUSD()).div(1e18);\n            } else {\n                uint balanceToken0 = IERC20(IEvmoSwapPair(asset).token0()).balanceOf(asset);\n                (uint token0PriceInETH,) = valueOfAsset(IEvmoSwapPair(asset).token0(), 1e18);\n\n                valueInETH = amount.mul(balanceToken0).mul(2).mul(token0PriceInETH).div(1e18).div(IEvmoSwapPair(asset).totalSupply());\n                valueInUSD = valueInETH.mul(ethPriceInUSD()).div(1e18);\n            }\n        } else {\n            address pairAddress = pairAddresses[asset];\n            if (pairAddress == address(0)) {\n                pairAddress = address(weth);\n            }\n\n            address pair = factory.getPair(asset, pairAddress);\n            if (pair == address(0) || IERC20(asset).balanceOf(pair) == 0) {\n                valueInETH = 0;\n            } else {\n                valueInETH = IERC20(pairAddress).balanceOf(pair).mul(amount).div(IERC20(asset).balanceOf(pair));\n                if (pairAddress != address(weth)) {\n                    (uint pairValueInETH,) = valueOfAsset(pairAddress, 1e18);\n                    valueInETH = valueInETH.mul(pairValueInETH).div(1e18);\n                }\n            }\n            valueInUSD = valueInETH.mul(ethPriceInUSD()).div(1e18);\n        }\n    }\n\n    /* ========== APY Calculation ========== */\n\n    function apyOfPool(uint256 pid) public view returns (uint apyPool) {\n        (address token,uint256 workingSupply,,,,,) = master.poolInfo(pid);\n        (uint valueInETH,) = valueOfAsset(token, workingSupply);\n\n        (uint rewardPriceInETH,) = valueOfAsset(address(reward), 1e18);\n        uint _rewardPerYearOfPool = rewardPerYearOfPool(pid);\n        if (_rewardPerYearOfPool == 0) {\n            return 0;\n        } else if (valueInETH == 0) {\n            return 10000 * (10 ** 18);\n        } else {\n            // 40%\n            return (master.TOKENLESS_PRODUCTION()).mul(rewardPriceInETH).mul(_rewardPerYearOfPool).div(valueInETH).div(100);\n        }\n    }\n\n    function apyOfPools(uint256[] memory pids) public view returns (uint[] memory apyPool) {\n        apyPool = new uint[](pids.length);\n        for (uint256 i = 0; i < pids.length; i++) {\n            apyPool[i] = apyOfPool(pids[i]);\n        }\n    }\n\n    function boostApyOfPool(uint256 pid, address user) public view returns (uint apyPool) {\n        (address token,uint256 workingSupply,,,,,) = master.poolInfo(pid);\n        (uint256 amount, uint256 workingAmount,) = master.userInfo(pid, user);\n        if (workingAmount == 0) {\n            return apyOfPool(pid);\n        }\n\n        (uint valueInETH,) = valueOfAsset(token, amount);\n        (uint rewardPriceInETH,) = valueOfAsset(address(reward), 1e18);\n        uint _rewardPerYearOfPool = rewardPerYearOfPool(pid).mul(workingAmount).div(workingSupply);\n        if (_rewardPerYearOfPool == 0) {\n            return 0;\n        } else if (valueInETH == 0) {\n            return 10000 * (10 ** 18);\n        } else {\n            return rewardPriceInETH.mul(_rewardPerYearOfPool).div(valueInETH);\n        }\n    }\n\n    function boostApyOfPools(uint256[] memory pids) public view returns (uint[] memory apyPool) {\n        apyPool = new uint[](pids.length);\n        for (uint256 i = 0; i < pids.length; i++) {\n            apyPool[i] = apyOfPool(pids[i]);\n        }\n    }\n\n    /* ========== TVL Calculation ========== */\n    function tvlOfPool(uint256 pid) public view returns (uint256 allocPoint, uint tvl, uint tvlInUSD) {\n        (address token,,,uint256 _allocPoint,,,) = master.poolInfo(pid);\n        allocPoint = _allocPoint;\n        tvl = IERC20(token).balanceOf(address(master));\n        (, tvlInUSD) = valueOfAsset(token, tvl);\n    }\n\n    function tvlOfPools(uint256[] memory pids) public view returns (uint totalTvl, uint totalTvlInUSD, uint256[] memory allocPoint, uint[] memory tvl, uint[] memory tvlInUSD) {\n        totalTvl = 0;\n        totalTvlInUSD = 0;\n        allocPoint = new uint256[](pids.length);\n        tvl = new uint[](pids.length);\n        tvlInUSD = new uint[](pids.length);\n        for (uint256 i = 0; i < pids.length; i++) {\n            (allocPoint[i], tvl[i], tvlInUSD[i]) = tvlOfPool(pids[i]);\n            totalTvl = totalTvl.add(tvl[i]);\n            totalTvlInUSD = totalTvlInUSD.add(tvlInUSD[i]);\n        }\n    }\n\n    function infoOfPools(uint256[] memory pids) public view returns (uint tokenPrice, uint totalTvl, uint totalTvlInUSD, uint256[] memory allocPoint, uint[] memory apy, uint[] memory tvl, uint[] memory tvlInUSD) {\n        totalTvl = 0;\n        totalTvlInUSD = 0;\n        allocPoint = new uint256[](pids.length);\n        apy = new uint[](pids.length);\n        tvl = new uint[](pids.length);\n        tvlInUSD = new uint[](pids.length);\n        tokenPrice = rewardPriceInUSD();\n        for (uint256 i = 0; i < pids.length; i++) {\n            apy[i] = apyOfPool(pids[i]);\n            (allocPoint[i], tvl[i], tvlInUSD[i]) = tvlOfPool(pids[i]);\n            totalTvl = totalTvl.add(tvl[i]);\n            totalTvlInUSD = totalTvlInUSD.add(tvlInUSD[i]);\n        }\n    }\n\n    function boostInfoOfPools(uint256[] memory pids, address user) public view returns (uint tokenPrice, uint totalTvl, uint totalTvlInUSD, uint256[] memory allocPoint, uint[] memory apy, uint[] memory boostApy, uint[] memory tvl, uint[] memory tvlInUSD) {\n        totalTvl = 0;\n        totalTvlInUSD = 0;\n        allocPoint = new uint256[](pids.length);\n        apy = new uint[](pids.length);\n        boostApy = new uint[](pids.length);\n        tvl = new uint[](pids.length);\n        tvlInUSD = new uint[](pids.length);\n        tokenPrice = rewardPriceInUSD();\n        for (uint256 i = 0; i < pids.length; i++) {\n            apy[i] = apyOfPool(pids[i]);\n            boostApy[i] = boostApyOfPool(pids[i], user);\n            (allocPoint[i], tvl[i], tvlInUSD[i]) = tvlOfPool(pids[i]);\n            totalTvl = totalTvl.add(tvl[i]);\n            totalTvlInUSD = totalTvlInUSD.add(tvlInUSD[i]);\n        }\n    }\n}"
    },
    "contracts/libraries/SafeDecimal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary SafeDecimal {\n    using SafeMath for uint;\n\n    uint8 public constant decimals = 18;\n    uint public constant UNIT = 10 ** uint(decimals);\n\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    function multiply(uint x, uint y) internal pure returns (uint) {\n        return x.mul(y).div(UNIT);\n    }\n\n    // https://mpark.github.io/programming/2014/08/18/exponentiation-by-squaring/\n    function power(uint x, uint n) internal pure returns (uint) {\n        uint result = UNIT;\n        while (n > 0) {\n            if (n % 2 != 0) {\n                result = multiply(result, x);\n            }\n            x = multiply(x, x);\n            n /= 2;\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/interfaces/IEvmoSwapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IEvmoSwapPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function pairFee() external view returns (uint32);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n    function setPairFee(uint32) external;\n}\n"
    },
    "contracts/interfaces/IEvmoSwapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IEvmoSwapFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setPairFee(address pair, uint32 pairFee) external;\n}"
    },
    "contracts/swap/EvmoSwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport '../interfaces/IWETH.sol';\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\nimport '../libraries/TransferHelper.sol';\nimport '../interfaces/IEvmoSwapFactory.sol';\nimport '../interfaces/IEvmoSwapRouter02.sol';\nimport '../libraries/EvmoSwapLibrary.sol';\n\ncontract EvmoSwapRouter is IEvmoSwapRouter02 {\n    using SafeMath for uint;\n\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'EvmoSwapRouter: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _WETH) public {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        if (IEvmoSwapFactory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IEvmoSwapFactory(factory).createPair(tokenA, tokenB);\n        }\n        (uint reserveA, uint reserveB) = EvmoSwapLibrary.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = EvmoSwapLibrary.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'EvmoSwapRouter: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = EvmoSwapLibrary.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'EvmoSwapRouter: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = EvmoSwapLibrary.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IEvmoSwapPair(pair).mint(to);\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = EvmoSwapLibrary.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IEvmoSwapPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = EvmoSwapLibrary.pairFor(factory, tokenA, tokenB);\n        IEvmoSwapPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IEvmoSwapPair(pair).burn(to);\n        (address token0,) = EvmoSwapLibrary.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'EvmoSwapRouter: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'EvmoSwapRouter: INSUFFICIENT_B_AMOUNT');\n    }\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) {\n        address pair = EvmoSwapLibrary.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IEvmoSwapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        address pair = EvmoSwapLibrary.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IEvmoSwapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) {\n        address pair = EvmoSwapLibrary.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IEvmoSwapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = EvmoSwapLibrary.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? EvmoSwapLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            IEvmoSwapPair(EvmoSwapLibrary.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = EvmoSwapLibrary.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'EvmoSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, EvmoSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = EvmoSwapLibrary.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'EvmoSwapRouter: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, EvmoSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'EvmoSwapRouter: INVALID_PATH');\n        amounts = EvmoSwapLibrary.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'EvmoSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(EvmoSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'EvmoSwapRouter: INVALID_PATH');\n        amounts = EvmoSwapLibrary.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'EvmoSwapRouter: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, EvmoSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'EvmoSwapRouter: INVALID_PATH');\n        amounts = EvmoSwapLibrary.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'EvmoSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, EvmoSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'EvmoSwapRouter: INVALID_PATH');\n        amounts = EvmoSwapLibrary.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= msg.value, 'EvmoSwapRouter: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(EvmoSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = EvmoSwapLibrary.sortTokens(input, output);\n            IEvmoSwapPair pair = IEvmoSwapPair(EvmoSwapLibrary.pairFor(factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = EvmoSwapLibrary.getAmountOut(amountInput, reserveInput, reserveOutput, pair.pairFee());\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? EvmoSwapLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, EvmoSwapLibrary.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'EvmoSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    {\n        require(path[0] == WETH, 'EvmoSwapRouter: INVALID_PATH');\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(IWETH(WETH).transfer(EvmoSwapLibrary.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'EvmoSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    {\n        require(path[path.length - 1] == WETH, 'EvmoSwapRouter: INVALID_PATH');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, EvmoSwapLibrary.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'EvmoSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n        return EvmoSwapLibrary.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint pairFee)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountOut)\n    {\n        return EvmoSwapLibrary.getAmountOut(amountIn, reserveIn, reserveOut, pairFee);\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint pairFee)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountIn)\n    {\n        return EvmoSwapLibrary.getAmountIn(amountOut, reserveIn, reserveOut, pairFee);\n    }\n\n    function getAmountsOut(uint amountIn, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return EvmoSwapLibrary.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(uint amountOut, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return EvmoSwapLibrary.getAmountsIn(factory, amountOut, path);\n    }\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}"
    },
    "contracts/interfaces/IEvmoSwapRouter02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport './IEvmoSwapRouter01.sol';\n\ninterface IEvmoSwapRouter02 is IEvmoSwapRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/libraries/EvmoSwapLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport \"./SafeMath.sol\";\nimport '../interfaces/IEvmoSwapPair.sol';\n\nlibrary EvmoSwapLibrary {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'EvmoSwapLibrary: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'EvmoSwapLibrary: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'1a74734eea11bc0ee7528f77a3306d46a0e9015d2eca65dd5651259a4b2eefe1' // init code hash\n            ))));\n    }\n\n    function getPairFee(address factory, address tokenA, address tokenB) internal view returns (uint pairFee) {\n        pairFee = IEvmoSwapPair(pairFor(factory, tokenA, tokenB)).pairFee();\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        pairFor(factory, tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IEvmoSwapPair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'EvmoSwapLibrary: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'EvmoSwapLibrary: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint pairFee) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'EvmoSwapLibrary: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'EvmoSwapLibrary: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(uint(10000).sub(pairFee));\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(10000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint pairFee) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'EvmoSwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'EvmoSwapLibrary: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(10000);\n        uint denominator = reserveOut.sub(amountOut).mul(uint(10000).sub(pairFee));\t\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'EvmoSwapLibrary: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, getPairFee(factory, path[i], path[i + 1]));\t\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'EvmoSwapLibrary: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut, getPairFee(factory, path[i - 1], path[i]));\t\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IEvmoSwapRouter01.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IEvmoSwapRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint pairFee) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint pairFee) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/interfaces/IEvmoSwapCallee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IEvmoSwapCallee {\n    function evmosCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/swap/EvmoSwapMigrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport '../libraries/TransferHelper.sol';\nimport '../interfaces/IEvmoSwapMigrator.sol';\nimport '../interfaces/IEvmoSwapFactory.sol';\nimport '../interfaces/IEvmoSwapRouter01.sol';\nimport '../interfaces/IERC20.sol';\n\ncontract EvmoSwapMigrator is IEvmoSwapMigrator {\n    IEvmoSwapRouter01 immutable router;\n    IEvmoSwapFactory immutable factoryV1;\n\n    constructor(address _factoryV1, address _router) public {\n        factoryV1 = IEvmoSwapFactory(_factoryV1);\n        router = IEvmoSwapRouter01(_router);\n    }\n\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external override {\n        //\n    }\n}"
    },
    "contracts/interfaces/IEvmoSwapMigrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IEvmoSwapMigrator {\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;\n}"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../interfaces/IERC20.sol\";\n\nlibrary SafeERC20 {\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeName(IERC20 token) internal view returns(string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeDecimals(IERC20 token) public view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeERC20: Transfer failed\");\n    }\n\n    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeERC20: TransferFrom failed\");\n    }\n}"
    },
    "contracts/tools/EvmosFaucet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\nimport \"../libraries/SafeMath.sol\";\nimport \"../libraries/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract EvmosFaucet is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public treasury;\n\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    uint256 public constant FAUCET_AMOUNT = 50; // 50 pre address\n\n    constructor(\n        address _dai,\n        address _usdc,\n        address _usdt\n    ) public {\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        treasury = msg.sender;\n    }\n\n    receive() external payable {}\n\n    function faucetTokenWithETH(address _token) external payable {\n        require(msg.value > 0, \"No ETH sent\");\n        uint decimals = IERC20(_token).decimals();\n        require(IERC20(_token).balanceOf(address(this)) >= FAUCET_AMOUNT.mul(10 ** decimals), 'Not enough faucet token');\n\n        IERC20(_token).safeTransfer(_msgSender(), FAUCET_AMOUNT.mul(10 ** decimals));\n    }\n\n    function adminWithdrawETH() external onlyOwner {\n        require(address(this).balance > 0, \"No ETH to withdraw\");\n\n        (bool success,) = treasury.call{value : address(this).balance}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function adminWithdrawERC20(address ERC20token) external onlyOwner {\n        uint256 withdrawAmount = IERC20(ERC20token).balanceOf(address(this));\n        require(withdrawAmount > 0, \"No ERC20 to withdraw\");\n\n        IERC20(ERC20token).safeTransfer(treasury, withdrawAmount);\n    }\n}"
    },
    "contracts/staking/RewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IMasterChef.sol\";\nimport \"../interfaces/IOnwardIncentivesController.sol\";\n\ncontract RewardPool is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n    }\n\n    IMasterChef public immutable masterchef;\n\n    // Staking token\n    IERC20 public immutable stakingToken;\n    // Reward token\n    IERC20 public immutable rewardToken;\n    uint256 public rewardPerTokenStored;\n    // Info of each user that stakes LP tokens.\n    mapping(address => UserInfo) public userInfo;\n    // address of votingEscrow\n    address public immutable operator;\n    // bonus reward\n    IOnwardIncentivesController incentivesController;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 amount);\n    event Harvest(address indexed from, address indexed to, uint256 t);\n\n    /**\n     * @notice Constructor\n     * @param _stakingToken: Staking token contract\n     * @param _rewardToken: Rewarding token contract\n     * @param _masterchef: MasterChef contract\n     * @param _operator: address of the operator\n     */\n    constructor(\n        IERC20 _stakingToken,\n        IERC20 _rewardToken,\n        IMasterChef _masterchef,\n        address _operator\n    ) public {\n        stakingToken = _stakingToken;\n        rewardToken = _rewardToken;\n        masterchef = _masterchef;\n        operator = _operator;\n\n        // Infinite approve\n        IERC20(_stakingToken).safeApprove(address(_masterchef), uint256(~0));\n    }\n\n    // only votingEscrow\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"!operator\");\n        _;\n    }\n\n    function setIncentivesController(IOnwardIncentivesController _incentivesController) external onlyOwner {\n        incentivesController = _incentivesController;\n    }\n\n    function depositFor(address _user, uint256 _amount) external onlyOperator returns (bool) {\n        UserInfo storage user = userInfo[_user];\n\n        // reward balance before deposit\n        uint256 rewardBalanceBefore = rewardToken.balanceOf(address(this));\n\n        // deposit\n        (uint256 poolAmountBeforeDeposit,,) = masterchef.userInfo(0, address(this));\n        uint _userAmountBeforeDeposit = user.amount;\n        if (_amount > 0) {\n            stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n            user.amount = _userAmountBeforeDeposit.add(_amount);\n        }\n        masterchef.enterStaking(_amount);\n\n        // reward token received\n        uint256 rewardTokenReceived = rewardToken.balanceOf(address(this)).sub(rewardBalanceBefore);\n\n        // update reward info\n        uint _rewardPerTokenStored = rewardPerTokenStored;\n        if (rewardTokenReceived != 0 && poolAmountBeforeDeposit != 0) {\n            _rewardPerTokenStored = _rewardPerTokenStored.add(rewardTokenReceived.mul(1e12).div(poolAmountBeforeDeposit));\n        }\n\n        // send reward\n        uint _rewardAmount = _rewardPerTokenStored * _userAmountBeforeDeposit / 1e12 - user.rewardDebt;\n        if (_rewardAmount > 0) {\n            rewardToken.safeTransfer(_user, _rewardAmount);\n        }\n        user.rewardDebt = _rewardPerTokenStored * (_userAmountBeforeDeposit + _amount) / 1e12;\n        rewardPerTokenStored = _rewardPerTokenStored;\n\n        // bonus\n        if (address(incentivesController) != address(0)) {\n            incentivesController.onReward(_user, user.amount);\n        }\n\n        emit Deposit(_user, _amount);\n        return true;\n    }\n\n    function withdrawFor(address _user, uint256 _amount) external onlyOperator returns (bool) {\n        return _withdraw(_user, msg.sender, _amount);\n    }\n\n    function harvest(address _user) external {\n        _withdraw(_user, operator, 0);\n        emit Harvest(msg.sender, _user, block.timestamp);\n    }\n\n    function emergencyWithdraw(address _user) external onlyOperator {\n        masterchef.emergencyWithdraw(0);\n        UserInfo storage user = userInfo[_user];\n        stakingToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(_user, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n    }\n\n    function _withdraw(address from, address to, uint256 _amount) internal returns (bool) {\n        require(to != address(this), \"!To\");\n        UserInfo storage user = userInfo[from];\n\n        // reward balance before deposit\n        uint256 rewardBalanceBefore = rewardToken.balanceOf(address(this));\n\n        // withdraw\n        (uint256 poolAmountBeforeWithdraw,,) = masterchef.userInfo(0, address(this));\n        uint _userAmountBeforeWithdraw = user.amount;\n        // adjust amount\n        _amount = _amount > _userAmountBeforeWithdraw ? _userAmountBeforeWithdraw : _amount;\n        masterchef.enterStaking(_amount);\n        if (_amount > 0) {\n            stakingToken.safeTransfer(to, _amount);\n            user.amount = _userAmountBeforeWithdraw - _amount;\n        }\n\n        // reward token received\n        uint256 rewardTokenReceived = rewardToken.balanceOf(address(this)).sub(rewardBalanceBefore);\n\n        // update reward info\n        uint _rewardPerTokenStored = rewardPerTokenStored;\n        if (rewardTokenReceived != 0 && poolAmountBeforeWithdraw != 0) {\n            _rewardPerTokenStored = _rewardPerTokenStored.add(rewardTokenReceived.mul(1e12).div(poolAmountBeforeWithdraw));\n        }\n\n        // send reward\n        uint _rewardAmount = _rewardPerTokenStored * _userAmountBeforeWithdraw / 1e12 - user.rewardDebt;\n        if (_rewardAmount > 0) {\n            rewardToken.safeTransfer(from, _rewardAmount);\n        }\n        user.rewardDebt = _rewardPerTokenStored * (_userAmountBeforeWithdraw - _amount) / 1e12;\n        rewardPerTokenStored = _rewardPerTokenStored;\n\n        // bonus\n        if (address(incentivesController) != address(0)) {\n            incentivesController.onReward(from, user.amount);\n        }\n\n        emit Withdraw(from, _amount);\n        return true;\n    }\n\n    function pendingTokens(address _user) external view returns (address[] memory tokens, uint[] memory amounts) {\n        uint incentives = 0;\n        address _incentivesControllerAddr = address(incentivesController);\n        while (_incentivesControllerAddr != address(0)) {\n            incentives++;\n            _incentivesControllerAddr = IOnwardIncentivesController(_incentivesControllerAddr).getNextIncentivesController();\n        }\n\n        tokens = new address[](incentives + 1);\n        amounts = new uint[](incentives + 1);\n\n        // 0 -> rewardToken\n        (uint256 poolAmount,,) = masterchef.userInfo(0, address(this));\n        (, uint[] memory _amounts) = masterchef.pendingTokens(0, address(this));\n        uint _rewardPerTokenStored = rewardPerTokenStored;\n        if (_amounts[0] != 0 && poolAmount != 0) {\n            _rewardPerTokenStored = _rewardPerTokenStored.add(_amounts[0].mul(1e12).div(poolAmount));\n        }\n        tokens[0] = address(rewardToken);\n        amounts[0] = _rewardPerTokenStored * userInfo[_user].amount / 1e12 - userInfo[_user].rewardDebt;\n\n        // bonus\n        uint i = 1;\n        IOnwardIncentivesController _incentivesController = incentivesController;\n        while (address(_incentivesController) != address(0)) {\n            tokens[i] = address(_incentivesController.rewardToken());\n            amounts[i] = _incentivesController.pendingTokens(_user);\n            _incentivesController = IOnwardIncentivesController(_incentivesController.getNextIncentivesController());\n            i++;\n        }\n    }\n}"
    },
    "contracts/staking/MasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./EMOToken.sol\";\nimport \"../interfaces/IOnwardIncentivesController.sol\";\nimport \"../interfaces/IMultiFeeDistribution.sol\";\n\ncontract MasterChef is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount;     // How many LP tokens the user has provided.\n        uint256 workingAmount; // Take voting power into consideration\n        uint256 rewardDebt; // Reward debt. See explanation below.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken;           // Address of LP token contract.\n        uint256 workingSupply;      // Take voting power into consideration\n        bool boost;\n        uint256 allocPoint;       // How many allocation points assigned to this pool. EMOs to distribute per second.\n        uint256 lastRewardTime;  // Last second number that EMOs distribution occurs.\n        uint256 accEmoPerShare; // Accumulated EMOs per share, times 1e12. See below.\n        uint256 depositFeePercent;      // Deposit fee in basis points\n        IOnwardIncentivesController incentivesController; // bonus reward\n    }\n\n    // 40/100=2.5X\n    uint256 public constant TOKENLESS_PRODUCTION = 40;\n\n    // The EMO TOKEN!\n    EMOToken public emo;\n    //Pools, Farms, Dev, Refs percent decimals\n    uint256 public percentDec = 1000000;\n    //Pools and Farms percent from token per block\n    uint256 public stakingPercent;\n    //Developers percent from token per block\n    uint256 public devPercent;\n    //Safu fund percent from token per block\n    uint256 public safuPercent;\n    //Referrals percent from token per block\n    uint256 public refPercent;\n    // Dev address.\n    address public devaddr;\n    // Safu fund.\n    address public safuaddr;\n    // Refferals commision address.\n    address public refAddr;\n    // Deposit Fee address\n    address public feeAddr;\n    // Last block then develeper withdraw dev and ref fee\n    uint256 public lastTimeDevWithdraw;\n    // The Reward Minter!\n    IMultiFeeDistribution public rewardMinter;\n    // Voting power\n    address public votingEscrow;\n    // EMO tokens created per second.\n    uint256 public emoPerSecond;\n    // Bonus muliplier for early emo makers.\n    uint256 public BONUS_MULTIPLIER = 1;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    // Info of each user that stakes LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    mapping(IERC20 => bool) public poolExistence;\n    // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint = 0;\n    // The second number when EMO mining starts.\n    uint256 public startTime;\n    // Only EOA or contract whitelisted is allowed to deposit\n    bool public whitelistable;\n    mapping(address => bool) public whitelist;\n    // Only user whitelisted is allowed to deposit pool 0\n    mapping(address => bool) pool0Staker;\n\n    event Add(uint256 indexed pid, uint256 allocPoint, IERC20 indexed lpToken, IOnwardIncentivesController indexed incentivesController, bool boost);\n    event Set(uint256 indexed pid, uint256 allocPoint, IOnwardIncentivesController indexed incentivesController);\n    event Deposit(address indexed from, address indexed to, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    modifier nonDuplicated(IERC20 _lpToken) {\n        require(poolExistence[_lpToken] == false, \"nonDuplicated: duplicated\");\n        _;\n    }\n\n    constructor(\n        EMOToken _emo,\n        uint256 _stakingPercent,\n        uint256 _devPercent,\n        uint256 _safuPercent,\n        uint256 _refPercent,\n        address _devaddr,\n        address _safuaddr,\n        address _refAddr,\n        address _feeAddr,\n        IMultiFeeDistribution _rewardMinter,\n        uint256 _emoPerSecond,\n        address _votingEscrow\n    ) public {\n        emo = _emo;\n        stakingPercent = _stakingPercent;\n        devPercent = _devPercent;\n        safuPercent = _safuPercent;\n        refPercent = _refPercent;\n        devaddr = _devaddr;\n        safuaddr = _safuaddr;\n        refAddr = _refAddr;\n        feeAddr = _feeAddr;\n        rewardMinter = _rewardMinter;\n        emoPerSecond = _emoPerSecond;\n        votingEscrow = _votingEscrow;\n        whitelistable = true;\n    }\n\n    function setStartTime(uint256 _startTime) public onlyOwner {\n        require(startTime == 0, \"startTime has been set\");\n        startTime = _startTime;\n\n        // staking pool\n        poolInfo.push(PoolInfo({\n            lpToken : emo,\n            workingSupply : 0,\n            boost : false,\n            allocPoint : 100,\n            lastRewardTime : startTime,\n            accEmoPerShare : 0,\n            depositFeePercent : 0,\n            incentivesController : IOnwardIncentivesController(address(0))\n        }));\n\n        poolExistence[emo] = true;\n        totalAllocPoint = 100;\n\n    }\n\n    function updateMultiplier(uint256 multiplierNumber) public onlyOwner {\n        BONUS_MULTIPLIER = multiplierNumber;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    function toggleWhitelistable() external onlyOwner {\n        whitelistable = !whitelistable;\n    }\n\n    function setWhitelist(address [] memory _users, bool _flag) external onlyOwner {\n        for (uint i = 0; i < _users.length; i++) {\n            whitelist[_users[i]] = _flag;\n        }\n    }\n\n    function setPool0Staker(address [] memory _users, bool _flag) external onlyOwner {\n        for (uint i = 0; i < _users.length; i++) {\n            pool0Staker[_users[i]] = _flag;\n        }\n    }\n\n    function withdrawDevAndRefFee() public {\n        require(lastTimeDevWithdraw < block.timestamp, 'wait for new block');\n        uint256 multiplier = getMultiplier(lastTimeDevWithdraw, block.timestamp);\n        uint256 emoReward = multiplier.mul(emoPerSecond);\n        emo.mint(devaddr, emoReward.mul(devPercent).div(percentDec));\n        emo.mint(safuaddr, emoReward.mul(safuPercent).div(percentDec));\n        emo.mint(refAddr, emoReward.mul(refPercent).div(percentDec));\n        lastTimeDevWithdraw = block.timestamp;\n    }\n\n    // Add a new lp to the pool. Can only be called by the owner.\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    function add(uint256 _allocPoint, IERC20 _lpToken, uint256 _depositFeePercent, IOnwardIncentivesController _incentivesController, bool _boost, bool _withUpdate) public onlyOwner nonDuplicated(_lpToken) {\n        require(_depositFeePercent <= percentDec, \"set: invalid deposit fee basis points\");\n        require(startTime != 0, \"!startTime\");\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n\n        uint256 lastRewardTime = block.timestamp > startTime ? block.timestamp : startTime;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolExistence[_lpToken] = true;\n        poolInfo.push(PoolInfo({\n            lpToken : _lpToken,\n            workingSupply : 0,\n            boost : _boost,\n            allocPoint : _allocPoint,\n            lastRewardTime : lastRewardTime,\n            accEmoPerShare : 0,\n            depositFeePercent : _depositFeePercent,\n            incentivesController : _incentivesController\n        }));\n        emit Add(poolInfo.length.sub(1), _allocPoint, _lpToken, _incentivesController, _boost);\n    }\n\n    // Update the given pool's EMO allocation point. Can only be called by the owner.\n    function set(uint256 _pid, uint256 _allocPoint, uint256 _depositFeePercent, IOnwardIncentivesController _incentivesController, bool _withUpdate) public onlyOwner {\n        require(_depositFeePercent <= percentDec, \"set: invalid deposit fee basis points\");\n        require(startTime != 0, \"!startTime\");\n        require(_pid != 0 || address(_incentivesController) == address(0), \"!incentive\");\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 prevAllocPoint = poolInfo[_pid].allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n        poolInfo[_pid].depositFeePercent = _depositFeePercent;\n        poolInfo[_pid].incentivesController = _incentivesController;\n        if (prevAllocPoint != _allocPoint) {\n            totalAllocPoint = totalAllocPoint.sub(prevAllocPoint).add(_allocPoint);\n        }\n        emit Set(_pid, _allocPoint, _incentivesController);\n    }\n\n    // Return reward multiplier over the given _from to _to second.\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        return _to.sub(_from).mul(BONUS_MULTIPLIER);\n    }\n\n\n    function pendingTokens(uint256 _pid, address _user) external view returns (address[] memory tokens, uint[] memory amounts) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n\n        uint incentives = 0;\n        address _incentivesControllerAddr = address(pool.incentivesController);\n        while (_incentivesControllerAddr != address(0)) {\n            incentives++;\n            _incentivesControllerAddr = IOnwardIncentivesController(_incentivesControllerAddr).getNextIncentivesController();\n        }\n\n        tokens = new address[](incentives + 1);\n        amounts = new uint[](incentives + 1);\n\n        uint256 accEmoPerShare = pool.accEmoPerShare;\n        uint256 lpSupply = pool.workingSupply;\n        if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\n            uint256 multiplier = getMultiplier(pool.lastRewardTime, block.timestamp);\n            uint256 emoReward = multiplier.mul(emoPerSecond).mul(pool.allocPoint).div(totalAllocPoint).mul(stakingPercent).div(percentDec);\n            accEmoPerShare = accEmoPerShare.add(emoReward.mul(1e12).div(lpSupply));\n        }\n        tokens[0] = address(emo);\n        amounts[0] = user.workingAmount.mul(accEmoPerShare).div(1e12).sub(user.rewardDebt);\n\n        // bonus\n        uint i = 1;\n        IOnwardIncentivesController _incentivesController = pool.incentivesController;\n        while (address(_incentivesController) != address(0)) {\n            tokens[i] = address(_incentivesController.rewardToken());\n            amounts[i] = _incentivesController.pendingTokens(_user);\n            _incentivesController = IOnwardIncentivesController(_incentivesController.getNextIncentivesController());\n            i++;\n        }\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.timestamp <= pool.lastRewardTime) {\n            return;\n        }\n        uint256 lpSupply = pool.workingSupply;\n        if (lpSupply == 0) {\n            pool.lastRewardTime = block.timestamp;\n            return;\n        }\n        uint256 multiplier = getMultiplier(pool.lastRewardTime, block.timestamp);\n        uint256 emoReward = multiplier.mul(emoPerSecond).mul(pool.allocPoint).div(totalAllocPoint).mul(stakingPercent).div(percentDec);\n        pool.accEmoPerShare = pool.accEmoPerShare.add(emoReward.mul(1e12).div(lpSupply));\n        pool.lastRewardTime = block.timestamp;\n    }\n\n    // Deposit LP tokens to MasterChef for EMO allocation for _user\n    function depositFor(address _user, uint256 _pid, uint256 _amount) public nonReentrant {\n        require(!whitelistable || !_isContract(_user) || whitelist[_user], \"Contract is not in the whitelist\");\n        require(_pid != 0, 'deposit EMO by staking');\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        updatePool(_pid);\n        if (user.workingAmount > 0) {\n            uint256 pending = user.workingAmount.mul(pool.accEmoPerShare).div(1e12).sub(user.rewardDebt);\n            if (pending > 0) {\n                rewardMinter.mint(_user, pending, true);\n            }\n        }\n        if (_amount > 0) {\n            uint256 balanceBefore = pool.lpToken.balanceOf(address(this));\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n            _amount = pool.lpToken.balanceOf(address(this)).sub(balanceBefore);\n            if (pool.depositFeePercent > 0) {\n                uint256 depositFee = _amount.mul(pool.depositFeePercent).div(percentDec);\n                pool.lpToken.safeTransfer(feeAddr, depositFee);\n                _amount = _amount.sub(depositFee);\n            }\n            user.amount = user.amount.add(_amount);\n        }\n\n        if (pool.boost) {\n            uint256 votingBalance = IERC20(votingEscrow).balanceOf(_user);\n            uint256 votingTotal = IERC20(votingEscrow).totalSupply();\n            uint256 lim = user.amount * TOKENLESS_PRODUCTION / 100;\n            if (votingTotal > 0) {\n                lim += pool.lpToken.balanceOf(address(this)) * votingBalance / votingTotal * (100 - TOKENLESS_PRODUCTION) / 100;\n            }\n            lim = user.amount < lim ? user.amount : lim;\n            pool.workingSupply = pool.workingSupply + lim - user.workingAmount;\n            user.workingAmount = lim;\n        } else {\n            pool.workingSupply = pool.workingSupply + user.amount - user.workingAmount;\n            user.workingAmount = user.amount;\n        }\n\n        user.rewardDebt = user.workingAmount.mul(pool.accEmoPerShare).div(1e12);\n\n        // Interactions\n        IOnwardIncentivesController _incentivesController = pool.incentivesController;\n        if (address(_incentivesController) != address(0)) {\n            _incentivesController.onReward(_user, user.amount);\n        }\n\n        emit Deposit(msg.sender, _user, _pid, _amount);\n    }\n\n    // Deposit LP tokens to MasterChef for EMO allocation.\n    function deposit(uint256 _pid, uint256 _amount) public {\n        depositFor(msg.sender, _pid, _amount);\n    }\n\n    function harvestAllRewards(address _user) public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            if (userInfo[pid][_user].amount > 0) {\n                _withdraw(pid, _user, 0);\n            }\n        }\n    }\n\n    // Withdraw LP tokens from MasterChef.\n    function withdraw(uint256 _pid, uint256 _amount) public {\n        _withdraw(_pid, msg.sender, _amount);\n    }\n\n    // Withdraw LP tokens from MasterChef.\n    function _withdraw(uint256 _pid, address _user, uint256 _amount) internal nonReentrant {\n        require(_pid != 0, 'withdraw EMO by unstaking');\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        require(user.amount >= _amount, \"withdraw: not good\");\n\n        updatePool(_pid);\n        if (user.workingAmount > 0) {\n            uint256 pending = user.workingAmount.mul(pool.accEmoPerShare).div(1e12).sub(user.rewardDebt);\n            if (pending > 0) {\n                rewardMinter.mint(_user, pending, true);\n            }\n        }\n        if (_amount > 0) {\n            user.amount = user.amount.sub(_amount);\n            pool.lpToken.safeTransfer(address(_user), _amount);\n        }\n\n        if (pool.boost) {\n            uint256 votingBalance = IERC20(votingEscrow).balanceOf(_user);\n            uint256 votingTotal = IERC20(votingEscrow).totalSupply();\n            uint256 lim = user.amount * TOKENLESS_PRODUCTION / 100;\n            if (votingTotal > 0) {\n                lim += pool.lpToken.balanceOf(address(this)) * votingBalance / votingTotal * (100 - TOKENLESS_PRODUCTION) / 100;\n            }\n            lim = user.amount < lim ? user.amount : lim;\n            pool.workingSupply = pool.workingSupply + lim - user.workingAmount;\n            user.workingAmount = lim;\n        } else {\n            pool.workingSupply = pool.workingSupply + user.amount - user.workingAmount;\n            user.workingAmount = user.amount;\n        }\n\n        user.rewardDebt = user.workingAmount.mul(pool.accEmoPerShare).div(1e12);\n\n        // Interactions\n        IOnwardIncentivesController _incentivesController = pool.incentivesController;\n        if (address(_incentivesController) != address(0)) {\n            _incentivesController.onReward(_user, user.amount);\n        }\n\n        emit Withdraw(_user, _pid, _amount);\n    }\n\n    // Stake EMO tokens to MasterChef\n    function enterStaking(uint256 _amount) public nonReentrant {\n        require(pool0Staker[msg.sender], \"Not allow to enterStaking\");\n\n        PoolInfo storage pool = poolInfo[0];\n        UserInfo storage user = userInfo[0][msg.sender];\n        updatePool(0);\n        if (user.workingAmount > 0) {\n            uint256 pending = user.workingAmount.mul(pool.accEmoPerShare).div(1e12).sub(user.rewardDebt);\n            if (pending > 0) {\n                rewardMinter.mint(msg.sender, pending, true);\n            }\n        }\n        if (_amount > 0) {\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n            user.amount = user.amount.add(_amount);\n        }\n        pool.workingSupply = pool.workingSupply + user.amount - user.workingAmount;\n        user.workingAmount = user.amount;\n        user.rewardDebt = user.workingAmount.mul(pool.accEmoPerShare).div(1e12);\n\n        emit Deposit(msg.sender, msg.sender, 0, _amount);\n    }\n\n    // Withdraw EMO tokens from STAKING.\n    function leaveStaking(uint256 _amount) public nonReentrant {\n        PoolInfo storage pool = poolInfo[0];\n        UserInfo storage user = userInfo[0][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(0);\n        if (user.workingAmount > 0) {\n            uint256 pending = user.workingAmount.mul(pool.accEmoPerShare).div(1e12).sub(user.rewardDebt);\n            if (pending > 0) {\n                rewardMinter.mint(msg.sender, pending, true);\n            }\n        }\n        if (_amount > 0) {\n            user.amount = user.amount.sub(_amount);\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\n        }\n        pool.workingSupply = pool.workingSupply + user.amount - user.workingAmount;\n        user.workingAmount = user.amount;\n        user.rewardDebt = user.workingAmount.mul(pool.accEmoPerShare).div(1e12);\n\n        emit Withdraw(msg.sender, 0, _amount);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _pid) public nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        // working amount\n        if (pool.workingSupply >= user.workingAmount) {\n            pool.workingSupply = pool.workingSupply - user.workingAmount;\n        } else {\n            pool.workingSupply = 0;\n        }\n        user.workingAmount = 0;\n\n        // Interactions\n        IOnwardIncentivesController _incentivesController = pool.incentivesController;\n        if (address(_incentivesController) != address(0)) {\n            _incentivesController.onReward(msg.sender, 0);\n        }\n    }\n\n    function setEmoPerSecond(uint256 _emoPerSecond) public onlyOwner {\n        require(_emoPerSecond <= 5 * 1e18, \"Max per second 5 EMO\");\n        massUpdatePools();\n        emoPerSecond = _emoPerSecond;\n    }\n\n    function setDevAddress(address _devaddr) public onlyOwner {\n        devaddr = _devaddr;\n    }\n\n    function setRefAddress(address _refaddr) public onlyOwner {\n        refAddr = _refaddr;\n    }\n\n    function setSafuAddress(address _safuaddr) public onlyOwner {\n        safuaddr = _safuaddr;\n    }\n\n    function setFeeAddress(address _feeAddr) public onlyOwner {\n        require(_feeAddr != address(0), \"setFeeAddress: ZERO\");\n        feeAddr = _feeAddr;\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}"
    },
    "contracts/staking/EMOToken.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\n// EMOToken with Governance.\ncontract EMOToken is ERC20('EvmoSwap Token', 'EMO'), Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    EnumerableSet.AddressSet private _minters;\n    \n    uint256 constant public MAX_TOTAL_SUPPLY = 500000000 * 1e18;\n\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\n    function mint(address _to, uint256 _amount) public onlyMinter {\n        require(_amount.add(totalSupply()) <= MAX_TOTAL_SUPPLY, \"ERC20: over limit\");\n\n        _mint(_to, _amount);\n        _moveDelegates(address(0), _delegates[_to], _amount);\n    }\n\n    // Copied and modified from YAM code:\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\n    // Which is copied and modified from COMPOUND:\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n    /// @dev A record of each accounts delegate\n    mapping (address => address) internal _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator)\n    external\n    view\n    returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n    external\n    {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"EMO::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"EMO::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"EMO::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n    external\n    view\n    returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n    external\n    view\n    returns (uint256)\n    {\n        require(blockNumber < block.number, \"EMO::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n    internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying EMOs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n    internal\n    {\n        uint32 blockNumber = safe32(block.number, \"EMO::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n\n    function addMinter(address _addMinter) public onlyOwner returns (bool) {\n        require(_addMinter != address(0), \"EMO: _addMinter is the zero address\");\n        return EnumerableSet.add(_minters, _addMinter);\n    }\n\n    function delMinter(address _delMinter) public onlyOwner returns (bool) {\n        require(_delMinter != address(0), \"EMO: _delMinter is the zero address\");\n        return EnumerableSet.remove(_minters, _delMinter);\n    }\n\n    function getMinterLength() public view returns (uint256) {\n        return EnumerableSet.length(_minters);\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return EnumerableSet.contains(_minters, account);\n    }\n\n    function getMinter(uint256 _index) public view onlyOwner returns (address){\n        require(_index <= getMinterLength() - 1, \"EMO: index out of bounds\");\n        return EnumerableSet.at(_minters, _index);\n    }\n\n    // modifier for mint function\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"caller is not the minter\");\n        _;\n    }\n}"
    },
    "contracts/interfaces/IMultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IMultiFeeDistribution {\n    function mint(address user, uint256 amount, bool withPenalty) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/staking/MultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IMultiFeeDistribution.sol\";\n\ninterface IMintableToken is IERC20 {\n    function mint(address _receiver, uint256 _amount) external;\n\n    function addMinter(address _minter) external returns (bool);\n}\n\ncontract MultiFeeDistribution is IMultiFeeDistribution, Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IMintableToken;\n\n    /* ========== STATE VARIABLES ========== */\n    struct Balances {\n        uint256 total;\n        uint256 unlocked;\n        uint256 earned;\n    }\n\n    struct LockedBalance {\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    IMintableToken public immutable stakingToken;\n    // Address receive penalty\n    address public penaltyReceiver;\n\n    // Duration that rewards are streamed over\n    uint256 public constant WEEK = 86400 * 7;\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = WEEK * 4;\n\n    // Addresses approved to call mint\n    mapping(address => bool) public minters;\n    bool public mintersAreSet;\n\n    uint256 public totalSupply;\n\n    // Private mappings for balance data\n    mapping(address => Balances) private balances;\n    mapping(address => LockedBalance[]) private userEarnings;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _stakingToken, address _penaltyReceiver) public {\n        stakingToken = IMintableToken(_stakingToken);\n        penaltyReceiver = _penaltyReceiver;\n    }\n\n    /* ========== ADMIN CONFIGURATION ========== */\n\n    function setMinters(address[] memory _minters) external onlyOwner {\n        require(!mintersAreSet);\n        for (uint i; i < _minters.length; i++) {\n            minters[_minters[i]] = true;\n        }\n        mintersAreSet = true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    // Total balance of an account, including unlocked, locked and earned tokens\n    function totalBalance(address user) view external returns (uint256 amount) {\n        return balances[user].total;\n    }\n\n    // Information on the \"earned\" balances of a user\n    // Earned balances may be withdrawn immediately for a 50% penalty\n    function earnedBalances(\n        address user\n    ) view external returns (\n        uint256 total,\n        LockedBalance[] memory earningsData,\n        uint256[] memory index\n    ) {\n        LockedBalance[] storage earnings = userEarnings[user];\n\n        uint256 len;\n        for (uint i = 0; i < earnings.length; i++) {\n            if (earnings[i].unlockTime > block.timestamp) {\n                len++;\n            }\n        }\n\n        earningsData = new LockedBalance[](len);\n        index = new uint256[](len);\n\n        uint256 idx;\n        for (uint i = 0; i < earnings.length; i++) {\n            if (earnings[i].unlockTime > block.timestamp) {\n                earningsData[idx] = earnings[i];\n                index[idx] = i;\n                idx++;\n                total = total.add(earnings[i].amount);\n            }\n        }\n\n        return (total, earningsData, index);\n    }\n\n    // Final balance received and penalty balance paid by user upon calling exit\n    function withdrawableBalance(\n        address user\n    ) view public returns (\n        uint256 amount,\n        uint256 amountWithoutPenalty,\n        uint256 penaltyAmount\n    ) {\n        Balances storage bal = balances[user];\n        uint256 earned = bal.earned;\n        if (earned > 0) {\n            uint256 length = userEarnings[user].length;\n            for (uint i = 0; i < length; i++) {\n                uint256 earnedAmount = userEarnings[user][i].amount;\n                if (earnedAmount == 0) continue;\n                if (userEarnings[user][i].unlockTime > block.timestamp) {\n                    break;\n                }\n                amountWithoutPenalty = amountWithoutPenalty.add(earnedAmount);\n            }\n\n            penaltyAmount = earned.sub(amountWithoutPenalty).div(2);\n        }\n        amount = bal.unlocked.add(earned).sub(penaltyAmount);\n        return (amount, amountWithoutPenalty, penaltyAmount);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    // Mint new tokens\n    // Minted tokens receive rewards normally but incur a 50% penalty when\n    // withdrawn before lockDuration has passed.\n    function mint(address user, uint256 amount, bool withPenalty) external override {\n        require(minters[msg.sender], \"!minter\");\n        require(user != address(this), \"self\");\n\n        if (amount == 0) {\n            return;\n        }\n\n        stakingToken.mint(address(this), amount);\n        totalSupply = totalSupply.add(amount);\n        Balances storage bal = balances[user];\n        bal.total = bal.total.add(amount);\n        if (withPenalty) {\n            bal.earned = bal.earned.add(amount);\n            uint256 unlockTime = block.timestamp.div(WEEK).mul(WEEK).add(lockDuration);\n            LockedBalance[] storage earnings = userEarnings[user];\n            uint256 idx = earnings.length;\n            if (idx == 0 || (earnings[idx - 1].unlockTime > 0 && earnings[idx - 1].unlockTime < unlockTime)) {\n                earnings.push(LockedBalance({amount : amount, unlockTime : unlockTime}));\n            } else {\n                earnings[idx - 1].amount = earnings[idx - 1].amount.add(amount);\n                earnings[idx - 1].unlockTime = unlockTime;\n            }\n        } else {\n            bal.unlocked = bal.unlocked.add(amount);\n        }\n        emit Mint(user, amount, withPenalty);\n    }\n\n    // Withdraw earned tokens\n    // First withdraws unlocked tokens, then earned tokens\n    // incurs a 50% penalty which is distributed based on locked balances.\n    function withdraw(uint256 amount) public {\n        require(amount > 0, \"Cannot withdraw 0\");\n        Balances storage bal = balances[msg.sender];\n        uint256 penaltyAmount;\n\n        if (amount <= bal.unlocked) {\n            bal.unlocked = bal.unlocked.sub(amount);\n        } else {\n            uint256 remaining = amount.sub(bal.unlocked);\n            require(bal.earned >= remaining, \"Insufficient unlocked balance\");\n            bal.unlocked = 0;\n            bal.earned = bal.earned.sub(remaining);\n            for (uint i = 0;; i++) {\n                uint256 earnedAmount = userEarnings[msg.sender][i].amount;\n                if (earnedAmount == 0) continue;\n                if (penaltyAmount == 0 && userEarnings[msg.sender][i].unlockTime > block.timestamp) {\n                    penaltyAmount = remaining;\n                    require(bal.earned >= remaining, \"Insufficient balance after penalty\");\n                    bal.earned = bal.earned.sub(remaining);\n                    if (bal.earned == 0) {\n                        delete userEarnings[msg.sender];\n                        break;\n                    }\n                    remaining = remaining.mul(2);\n                }\n                if (remaining <= earnedAmount) {\n                    userEarnings[msg.sender][i].amount = earnedAmount.sub(remaining);\n                    break;\n                } else {\n                    delete userEarnings[msg.sender][i];\n                    remaining = remaining.sub(earnedAmount);\n                }\n            }\n        }\n\n        uint256 adjustedAmount = amount.add(penaltyAmount);\n        bal.total = bal.total.sub(adjustedAmount);\n        totalSupply = totalSupply.sub(adjustedAmount);\n        stakingToken.safeTransfer(msg.sender, amount);\n        if (penaltyAmount > 0) {\n            stakingToken.safeTransfer(penaltyReceiver, penaltyAmount);\n        }\n        emit Withdrawn(msg.sender, amount, penaltyAmount);\n    }\n\n    // Withdraw earned tokens\n    // Withdraws unexpired tokens by index\n    // incurs a 50% penalty which is distributed based on locked balances.\n    function withdrawByIndex(uint256 index) public {\n        LockedBalance memory earnings = userEarnings[msg.sender][index];\n        require(earnings.amount > 0, \"Cannot withdraw 0\");\n        require(earnings.unlockTime > block.timestamp, \"Token should be unexpired\");\n\n        uint amount = earnings.amount;\n        uint256 penaltyAmount = amount / 2;\n        delete userEarnings[msg.sender][index];\n\n        Balances storage bal = balances[msg.sender];\n        bal.earned = bal.earned.sub(amount);\n        bal.total = bal.total.sub(amount);\n        totalSupply = totalSupply.sub(amount);\n        stakingToken.safeTransfer(msg.sender, amount.sub(penaltyAmount));\n        if (penaltyAmount > 0) {\n            stakingToken.safeTransfer(penaltyReceiver, penaltyAmount);\n        }\n        emit Withdrawn(msg.sender, amount.sub(penaltyAmount), penaltyAmount);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        require(tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event Mint(address indexed user, uint256 amount, bool withPenalty);\n    event Withdrawn(address indexed user, uint256 receivedAmount, uint256 penaltyPaid);\n    event Recovered(address token, uint256 amount);\n}\n"
    },
    "contracts/tools/MerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract MerkleDistributor {\n    using SafeMath for uint256;\n\n    address public immutable token;\n    bytes32 public immutable merkleRoot;\n\n    // time to start claiming\n    uint256 public immutable startTime;\n    // duration in seconds for 50% penalty after start\n    uint256 public immutable penaltyDuration;\n    // This is a packed array of booleans.\n    mapping(uint256 => uint256) private collectedBitMap;\n    // amount of token collected by user\n    mapping(address => uint256) public collectedAmount;\n    mapping(address => uint256) public collectedTime;\n    // amount of token claimed by user\n    mapping(address => uint256) public claimedAmount;\n    // total unclaimed amount at beginning\n    uint256 public totalUnclaimed;\n    // total penalty\n    uint256 public totalPenalty;\n\n    // This event is triggered whenever a call to #collect succeeds.\n    event Collected(uint256 index, address account, uint256 amount, uint256 adjustAmount);\n\n    constructor(address token_, bytes32 merkleRoot_, uint256 _startTime, uint256 _penaltyDuration) public {\n        token = token_;\n        merkleRoot = merkleRoot_;\n        startTime = _startTime;\n        penaltyDuration = _penaltyDuration;\n    }\n\n    function isCollected(uint256 index) public view returns (bool) {\n        uint256 collectedWordIndex = index / 256;\n        uint256 collectedBitIndex = index % 256;\n        uint256 collectedWord = collectedBitMap[collectedWordIndex];\n        uint256 mask = (1 << collectedBitIndex);\n        return collectedWord & mask == mask;\n    }\n\n    function _setCollected(uint256 index) private {\n        uint256 collectedWordIndex = index / 256;\n        uint256 collectedBitIndex = index % 256;\n        collectedBitMap[collectedWordIndex] = collectedBitMap[collectedWordIndex] | (1 << collectedBitIndex);\n    }\n\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external {\n        require(block.timestamp >= startTime, \"MerkleDistributor: Not start.\");\n        require(!isCollected(index), 'MerkleDistributor: Drop already collected.');\n\n        // Verify the merkle proof.\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(MerkleProof.verify(merkleProof, merkleRoot, node), 'MerkleDistributor: Invalid proof.');\n\n        // Mark it collected and send the token.\n        _setCollected(index);\n\n        // calculate penalty\n        uint256 adjustAmount;\n        if (block.timestamp < startTime.add(penaltyDuration)) {\n            adjustAmount = amount / 2;\n            totalUnclaimed = totalUnclaimed.sub(amount);\n            totalPenalty = totalPenalty.add(amount - adjustAmount);\n        } else {\n            adjustAmount = adjustAmount.add(totalPenalty.mul(amount).div(totalUnclaimed));\n        }\n\n        if (adjustAmount > 0) {\n            require(IERC20(token).transfer(msg.sender, adjustAmount), 'MerkleDistributor: Transfer failed.');\n        }\n        emit Collected(index, account, amount, adjustAmount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "contracts/staking/StakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./StakingPoolInitializable.sol\";\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract StakingPoolFactory is Ownable {\n    event NewStakingPoolContract(address indexed stakingPool);\n\n    constructor() public {\n        //\n    }\n\n    /*\n     * @notice Deploy the pool\n     * @param _stakedToken: staked token address\n     * @param _rewardToken: reward token address\n     * @param _rewardPerBlock: reward per block (in rewardToken)\n     * @param _startBlock: start block\n     * @param _endBlock: end block\n     * @param _poolLimitPerUser: pool limit per user in stakedToken (if any, else 0)\n     * @param _admin: admin address with ownership\n     * @return address of new smart chef contract\n     */\n    function deployPool(\n        IERC20 _stakedToken,\n        IERC20 _rewardToken,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _bonusEndBlock,\n        uint256 _poolLimitPerUser,\n        address _admin\n    ) external onlyOwner {\n        require(_stakedToken.totalSupply() >= 0);\n        require(_rewardToken.totalSupply() >= 0);\n        require(_stakedToken != _rewardToken, \"Tokens must be be different\");\n\n        bytes memory bytecode = type(StakingPoolInitializable).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(_stakedToken, _rewardToken, _startBlock));\n        address stakingPoolAddress;\n\n        assembly {\n            stakingPoolAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n\n        StakingPoolInitializable(stakingPoolAddress).initialize(\n            _stakedToken,\n            _rewardToken,\n            _rewardPerBlock,\n            _startBlock,\n            _bonusEndBlock,\n            _poolLimitPerUser,\n            _admin\n        );\n\n        emit NewStakingPoolContract(stakingPoolAddress);\n    }\n}"
    },
    "contracts/staking/FeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ninterface IVotingEscrow {\n    struct Point {\n        int128 bias;\n        int128 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n\n    function userPointEpoch(address addr) external view returns (uint256);\n\n    function epoch() external view returns (uint256);\n\n    function userPointHistory(address addr, uint256 loc) external view returns (Point memory point);\n\n    function pointHistory(uint256 loc) external view returns (Point memory point);\n\n    function checkpoint() external;\n}\n\n/**\n * Independent of votingescrow's reward contract\n * As a tool for distributing rewards!\n */\ncontract FeeDistributor is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant WEEK = 7 * 86400;\n    uint256 public constant TOKEN_CHECKPOINT_DEADLINE = 86400;\n\n\n    uint256 public startTime;\n    uint256 public timeCursor;\n    mapping(address => uint256) public timeCursorOf;\n    mapping(address => uint256) public userEpochOf;\n\n    uint256 public lastTokenTime;\n    uint256[1000000000000000] public tokensPerWeek;\n\n    address public votingEscrow;\n    // EMO-EVMOS LP\n    address public token;\n    uint256 public tokenLastBalance;\n\n    // VE total supply at week bounds\n    uint256[1000000000000000] public veSupply;\n\n    bool public canCheckpointToken;\n    address public emergencyReturn;\n    bool public isKilled;\n\n    event ToggleAllowCheckpointToken(bool toggleFlag);\n    event CheckpointToken(uint256 time, uint256 tokens);\n    event Claimed(address indexed recipient, uint256 amount, uint256 claimEpoch, uint256 maxEpoch);\n\n    /***\n    * @notice Contract constructor\n    * @param _votingEscrow VotingEscrow contract address\n    * @param _startTime Epoch time for fee distribution to start\n    * @param _token Fee token address (EMO-EVMOS LP)\n    * @param _emergencyReturn Address to transfer `_token` balance to,if this contract is killed\n    ***/\n    constructor(address _votingEscrow, uint256 _startTime, address _token, address _emergencyReturn) public {\n        uint256 t = _startTime / WEEK * WEEK;\n        startTime = t;\n        lastTokenTime = t;\n        timeCursor = t;\n        token = _token;\n        votingEscrow = _votingEscrow;\n        emergencyReturn = _emergencyReturn;\n    }\n\n    function max(int128 x, int128 y) internal pure returns (int128 z) {\n        z = x < y ? y : x;\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    function _checkpointToken() internal {\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n        uint256 toDistribute = tokenBalance.sub(tokenLastBalance);\n        tokenLastBalance = tokenBalance;\n\n        uint256 t = lastTokenTime;\n        uint256 sinceLast = block.timestamp.sub(t);\n        lastTokenTime = block.timestamp;\n        uint256 thisWeek = t / WEEK * WEEK;\n        uint256 nextWeek = 0;\n\n        for (uint i; i < 20; i++) {\n            nextWeek = thisWeek + WEEK;\n            if (block.timestamp < nextWeek) {\n                if (sinceLast == 0 && block.timestamp == t) {\n                    tokensPerWeek[thisWeek] = tokensPerWeek[thisWeek].add(toDistribute);\n                } else {\n                    tokensPerWeek[thisWeek] = tokensPerWeek[thisWeek].add(toDistribute.mul(block.timestamp.sub(t)).div(sinceLast));\n                }\n                break;\n            } else {\n                if (sinceLast == 0 && nextWeek == t) {\n                    tokensPerWeek[thisWeek] = tokensPerWeek[thisWeek].add(toDistribute);\n                } else {\n                    tokensPerWeek[thisWeek] = tokensPerWeek[thisWeek].add(toDistribute.mul(nextWeek.sub(t)).div(sinceLast));\n                }\n            }\n            t = nextWeek;\n            thisWeek = nextWeek;\n        }\n\n        emit CheckpointToken(block.timestamp, toDistribute);\n    }\n\n    /***\n    * @notice Update the token checkpoint\n    * @dev Calculates the total number of tokens to be distributed in a given week.\n    * During setup for the initial distribution this function is only callable\n    * by the contract owner. Beyond initial distro, it can be enabled for anyone\n    * to call.\n    ***/\n    function checkpointToken() external {\n        require(msg.sender == owner()\n            || (canCheckpointToken && (block.timestamp > lastTokenTime + TOKEN_CHECKPOINT_DEADLINE)), \"Wrong user!\");\n        _checkpointToken();\n    }\n\n    function _findTimestampEpoch(address ve, uint256 _timestamp) internal view returns (uint256) {\n        uint256 _min = 0;\n        uint256 _max = IVotingEscrow(ve).epoch();\n        for (uint i; i < 128; i++) {\n            if (_min >= _max) {\n                break;\n            }\n            uint256 _mid = (_min + _max + 2) / 2;\n            IVotingEscrow.Point memory pt = IVotingEscrow(ve).pointHistory(_mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    function _findTimestampUserEpoch(address ve, address user, uint256 _timestamp, uint256 maxUserEpoch) internal view returns (uint256) {\n        uint256 _min = 0;\n        uint256 _max = maxUserEpoch;\n        for (uint i; i < 128; i++) {\n            if (_min >= _max) {\n                break;\n            }\n            uint256 _mid = (_min + _max + 2) / 2;\n            IVotingEscrow.Point memory pt = IVotingEscrow(ve).userPointHistory(user, _mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    /***\n    * @notice Get the veCRV balance for `_user` at `_timestamp`\n    * @param _user Address to query balance for\n    * @param _timestamp Epoch time\n    * @return uint256 veCRV balance\n    ***/\n    function veForAt(address _user, uint256 _timestamp) external view returns (uint256) {\n        address ve = votingEscrow; // gas savings\n        uint256 maxUserEpoch = IVotingEscrow(ve).userPointEpoch(_user);\n        uint256 epoch = _findTimestampUserEpoch(ve, _user, _timestamp, maxUserEpoch);\n        IVotingEscrow.Point memory pt = IVotingEscrow(ve).userPointHistory(_user, epoch);\n        return uint256(max(pt.bias - pt.slope * int128(_timestamp - pt.ts), 0));\n    }\n\n    function _checkpointTotalSupply() internal {\n        address ve = votingEscrow;\n        uint256 t = timeCursor;\n        uint256 roundedTimestamp = block.timestamp / WEEK * WEEK;\n        IVotingEscrow(ve).checkpoint();\n\n        for (uint i; i < 20; i++) {\n            if (t > roundedTimestamp) {\n                break;\n            } else {\n                uint256 epoch = _findTimestampEpoch(ve, t);\n                IVotingEscrow.Point memory pt = IVotingEscrow(ve).pointHistory(epoch);\n                int128 dt = 0;\n                if (t > pt.ts) {\n                    dt = int128(t - pt.ts);\n                }\n                veSupply[t] = uint256(max(pt.bias - pt.slope * dt, 0));\n            }\n            t += WEEK;\n        }\n\n        timeCursor = t;\n    }\n\n    /***\n    * @notice Update the veCRV total supply checkpoint\n    * @dev The checkpoint is also updated by the first claimant each\n    *   new epoch week. This function may be called independently\n    *   of a claim, to reduce claiming gas costs.\n    ***/\n    function checkpointTotalSupply() external {\n        _checkpointTotalSupply();\n    }\n\n    function _claim(address addr, address ve, uint256 _lastTokenTime) internal returns (uint256) {\n        uint256 userEpoch = 0;\n        uint256 toDistribute = 0;\n\n        uint256 maxUserEpoch = IVotingEscrow(ve).userPointEpoch(addr);\n        uint256 _startTime = startTime; // gas savings\n\n        // No lock = no fees\n        if (maxUserEpoch == 0) {\n            return 0;\n        }\n\n        uint256 weekCursor = timeCursorOf[addr];\n        if (weekCursor == 0) {\n            userEpoch = _findTimestampUserEpoch(ve, addr, _startTime, maxUserEpoch);\n        } else {\n            userEpoch = userEpochOf[addr];\n        }\n\n        if (userEpoch == 0) {\n            userEpoch = 1;\n        }\n\n        IVotingEscrow.Point memory userPoint = IVotingEscrow(ve).userPointHistory(addr, userEpoch);\n\n        if (weekCursor == 0) {\n            weekCursor = (userPoint.ts + WEEK - 1) / WEEK * WEEK;\n        }\n\n        if (weekCursor >= _lastTokenTime) {\n            return 0;\n        }\n\n        if (weekCursor < _startTime) {\n            weekCursor = _startTime;\n        }\n        // empty\n        IVotingEscrow.Point memory oldUserPoint;\n\n\n        for (uint i; i < 50; i++) {\n            if (weekCursor >= _lastTokenTime) {\n                break;\n            }\n\n            if (weekCursor >= userPoint.ts && userEpoch <= maxUserEpoch) {\n                userEpoch += 1;\n                oldUserPoint = IVotingEscrow.Point({bias : userPoint.bias, slope : userPoint.slope, ts : userPoint.ts, blk : userPoint.blk});\n                if (userEpoch > maxUserEpoch) {\n                    userPoint = IVotingEscrow.Point({bias : 0, slope : 0, ts : 0, blk : 0});\n                } else {\n                    userPoint = IVotingEscrow(ve).userPointHistory(addr, userEpoch);\n                }\n            } else {\n                int128 dt = int128(weekCursor - oldUserPoint.ts);\n                uint256 balanceOf = uint256(max(oldUserPoint.bias - dt * oldUserPoint.slope, 0));\n                if (balanceOf == 0 && userEpoch > maxUserEpoch) {\n                    break;\n                }\n                if (balanceOf > 0) {\n                    toDistribute = toDistribute.add(balanceOf.mul(tokensPerWeek[weekCursor]).div(veSupply[weekCursor]));\n                }\n\n                weekCursor += WEEK;\n            }\n        }\n\n        userEpoch = min(maxUserEpoch, userEpoch - 1);\n        userEpochOf[addr] = userEpoch;\n        timeCursorOf[addr] = weekCursor;\n\n        emit Claimed(addr, toDistribute, userEpoch, maxUserEpoch);\n\n        return toDistribute;\n    }\n\n    /***\n    * @notice Claim fees for `_addr`\n    * @dev Each call to claim look at a maximum of 50 user veCRV points.\n    *    For accounts with many veCRV related actions, this function\n    *    may need to be called more than once to claim all available\n    *    fees. In the `Claimed` event that fires, if `claim_epoch` is\n    *    less than `max_epoch`, the account may claim again.\n    * @param _addr Address to claim fees for\n    * @return uint256 Amount of fees claimed in the call\n    ***/\n    function claim(address _addr) public nonReentrant returns (uint256) {\n        require(!isKilled, \"Killed\");\n\n        if (block.timestamp >= timeCursor) {\n            _checkpointTotalSupply();\n        }\n\n        uint256 _lastTokenTime = lastTokenTime;\n\n        if (canCheckpointToken && (block.timestamp > _lastTokenTime + TOKEN_CHECKPOINT_DEADLINE)) {\n            _checkpointToken();\n            _lastTokenTime = block.timestamp;\n        }\n\n        _lastTokenTime = _lastTokenTime / WEEK * WEEK;\n\n        uint256 amount = _claim(_addr, votingEscrow, _lastTokenTime);\n        if (amount != 0) {\n            IERC20(token).safeTransfer(_addr, amount);\n            tokenLastBalance = tokenLastBalance.sub(amount);\n        }\n\n        return amount;\n    }\n\n    function claim() external returns (uint256) {\n        return claim(msg.sender);\n    }\n\n    /***\n    * @notice Make multiple fee claims in a single call\n    * @dev Used to claim for many accounts at once, or to make\n    *   multiple claims for the same address when that address\n    *   has significant veCRV history\n    * @param _receivers List of addresses to claim for. Claiming\n    *   terminates at the first `ZERO_ADDRESS`.\n    * @return bool success\n    ***/\n    function claimMany(address[] memory _receivers) external nonReentrant returns (bool) {\n        require(!isKilled, \"Killed\");\n\n        if (block.timestamp >= timeCursor) {\n            _checkpointTotalSupply();\n        }\n\n        uint256 _lastTokenTime = lastTokenTime;\n\n        if (canCheckpointToken && (block.timestamp > _lastTokenTime + TOKEN_CHECKPOINT_DEADLINE)) {\n            _checkpointToken();\n            _lastTokenTime = block.timestamp;\n        }\n\n        _lastTokenTime = _lastTokenTime / WEEK * WEEK;\n        address ve = votingEscrow;\n        address _token = token;\n        uint256 total = 0;\n\n        for (uint i; i < _receivers.length; i++) {\n            address addr = _receivers[i];\n            if (addr == address(0)) {\n                break;\n            }\n            uint256 amount = _claim(addr, ve, _lastTokenTime);\n            if (amount != 0) {\n                require(IERC20(_token).transfer(addr, amount), \"Transfer failed!\");\n                total = total.add(amount);\n            }\n        }\n\n        if (total != 0) {\n            tokenLastBalance = tokenLastBalance.sub(total);\n        }\n\n        return true;\n    }\n\n    /***\n    * @notice Receive EMO-EVMOS LP into the contract and trigger a token checkpoint\n    * @param _coin Address of the coin being received (must be EMO-EVMOS LP),just for preventing misoperation\n    * @return bool success\n    ***/\n    function distribute(address _coin) external returns (bool) {\n        require(_coin == token, \"Wrong coin!\");\n        require(!isKilled, \"Killed\");\n\n        uint256 amount = IERC20(_coin).balanceOf(msg.sender);\n        if (amount != 0) {\n            IERC20(_coin).transferFrom(msg.sender, address(this), amount);\n            if (canCheckpointToken && (block.timestamp > lastTokenTime + TOKEN_CHECKPOINT_DEADLINE)) {\n                _checkpointToken();\n            }\n        }\n\n        return true;\n    }\n\n    /***\n    * @notice Toggle permission for checkpointing by any account\n    ***/\n    function toggleAllowCheckpointToken() external onlyOwner {\n        bool flag = !canCheckpointToken;\n        canCheckpointToken = flag;\n        emit ToggleAllowCheckpointToken(flag);\n    }\n\n    /***\n    * @notice Kill the contract\n    * @dev Killing transfers the entire EMO-EVMOS LP balance to the emergency return address\n    *   and blocks the ability to claim or burn. The contract cannot be unkilled.\n    ***/\n    function killMe() external onlyOwner {\n        isKilled = true;\n        require(IERC20(token).transfer(emergencyReturn, IERC20(token).balanceOf(address(this))), \"Transfer failed!\");\n    }\n\n    /***\n    * @notice Recover ERC20 tokens from this contract\n    * @dev Tokens are sent to the emergency return address.\n    * @param _coin Token address\n    * @return bool success\n    ***/\n    function recoverBalance(address _coin) external onlyOwner returns (bool) {\n        require(_coin != token, \"Wrong coin!\");\n        IERC20(_coin).safeTransfer(emergencyReturn, IERC20(_coin).balanceOf(address(this)));\n        return true;\n    }\n}"
    },
    "contracts/stable/MetaSwapDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\nimport \"./IMetaSwap.sol\";\nimport \"./ISwap.sol\";\n\n/**\n * @title MetaSwapDeposit\n * @notice This contract flattens the LP token in a MetaSwap pool for easier user access.\n *\n * For example, suppose there exists a base Swap pool consisting of [DAI, USDC, USDT].\n * Then a MetaSwap pool can be created with [BUSD, BaseSwapLPToken] to allow trades between either\n * the LP token or the underlying tokens and BUSD.\n *\n * MetaSwapDeposit flattens the LP token and remaps them to [BUSD, DAI, USDC, USDT], allowing users\n * to ignore the dependency on BaseSwapLPToken.\n */\ncontract MetaSwapDeposit {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    ISwap public baseSwap;\n    IMetaSwap public metaSwap;\n    IERC20[] public baseTokens;\n    IERC20[] public metaTokens;\n    IERC20[] public tokens;\n    IERC20 public metaLPToken;\n\n    uint256 constant MAX_UINT256 = 2**256 - 1;\n\n    struct RemoveLiquidityImbalanceInfo {\n        ISwap baseSwap;\n        IMetaSwap metaSwap;\n        IERC20 metaLPToken;\n        uint8 baseLPTokenIndex;\n        bool withdrawFromBase;\n        uint256 leftoverMetaLPTokenAmount;\n    }\n\n    /**\n     * @notice Sets the address for the base swap contract, meta swap contract, and the\n     * meta swap LP token contract.\n     * @param _baseSwap the address of the base swap contract\n     * @param _metaSwap the address of the meta swap contract\n     * @param _metaLPToken the address of the meta swap LP token contract\n     */\n    constructor(\n        ISwap _baseSwap,\n        IMetaSwap _metaSwap,\n        IERC20 _metaLPToken\n    ) public {\n        // Check and approve base level tokens to be deposited to the base swap contract\n        for (uint8 i = 0; i < 32; i++) {\n            try _baseSwap.getToken(i) returns (IERC20 token) {\n                baseTokens.push(token);\n                token.approve(address(_baseSwap), MAX_UINT256);\n                token.approve(address(_metaSwap), MAX_UINT256);\n            } catch {\n                break;\n            }\n        }\n\n        // Check and approve meta level tokens to be deposited to the meta swap contract\n        IERC20 baseLPToken;\n        for (uint8 i = 0; i < 32; i++) {\n            try _metaSwap.getToken(i) returns (IERC20 token) {\n                baseLPToken = token;\n                metaTokens.push(token);\n                tokens.push(token);\n                token.approve(address(_metaSwap), MAX_UINT256);\n            } catch {\n                break;\n            }\n        }\n\n        tokens[tokens.length - 1] = baseTokens[0];\n        for (uint8 i = 1; i < baseTokens.length; i++) {\n            tokens.push(baseTokens[i]);\n        }\n\n        // Approve base swap LP token to be burned by the base swap contract for withdrawing\n        baseLPToken.approve(address(_baseSwap), MAX_UINT256);\n        // Approve meta swap LP token to be burned by the meta swap contract for withdrawing\n        _metaLPToken.approve(address(_metaSwap), MAX_UINT256);\n\n        // Initialize storage variables\n        baseSwap = _baseSwap;\n        metaSwap = _metaSwap;\n        metaLPToken = _metaLPToken;\n    }\n\n    // Mutative functions\n\n    /**\n     * @notice Swap two underlying tokens using the meta pool and the base pool\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256) {\n        tokens[tokenIndexFrom].safeTransferFrom(msg.sender, address(this), dx);\n        uint256 tokenToAmount =\n            metaSwap.swapUnderlying(\n                tokenIndexFrom,\n                tokenIndexTo,\n                dx,\n                minDy,\n                deadline\n            );\n        tokens[tokenIndexTo].safeTransfer(msg.sender, tokenToAmount);\n        return tokenToAmount;\n    }\n\n    /**\n     * @notice Add liquidity to the pool with the given amounts of tokens\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP token user minted and received\n     */\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256) {\n        IERC20[] memory memBaseTokens = baseTokens;\n        IERC20[] memory memMetaTokens = metaTokens;\n        uint256 baseLPTokenIndex = memMetaTokens.length - 1;\n\n        require(amounts.length == memBaseTokens.length + baseLPTokenIndex);\n\n        uint256 baseLPTokenAmount;\n        {\n            // Transfer base tokens from the caller and deposit to the base swap pool\n            uint256[] memory baseAmounts = new uint256[](memBaseTokens.length);\n            bool shouldDepositBaseTokens;\n            for (uint8 i = 0; i < memBaseTokens.length; i++) {\n                IERC20 token = memBaseTokens[i];\n                uint256 depositAmount = amounts[baseLPTokenIndex + i];\n                if (depositAmount > 0) {\n                    token.safeTransferFrom(\n                        msg.sender,\n                        address(this),\n                        depositAmount\n                    );\n                    baseAmounts[i] = token.balanceOf(address(this)); // account for any fees on transfer\n                    shouldDepositBaseTokens = true;\n                }\n            }\n            if (shouldDepositBaseTokens) {\n                baseLPTokenAmount = baseSwap.addLiquidity(\n                    baseAmounts,\n                    0,\n                    deadline\n                );\n            }\n        }\n\n        uint256 metaLPTokenAmount;\n        {\n            // Transfer remaining meta level tokens from the caller and deposit to the meta swap pool\n            uint256[] memory metaAmounts = new uint256[](metaTokens.length);\n            for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n                IERC20 token = memMetaTokens[i];\n                uint256 depositAmount = amounts[i];\n                if (depositAmount > 0) {\n                    token.safeTransferFrom(\n                        msg.sender,\n                        address(this),\n                        depositAmount\n                    );\n                    metaAmounts[i] = token.balanceOf(address(this)); // account for any fees on transfer\n                }\n            }\n            metaAmounts[baseLPTokenIndex] = baseLPTokenAmount;\n            metaLPTokenAmount = metaSwap.addLiquidity(\n                metaAmounts,\n                minToMint,\n                deadline\n            );\n        }\n\n        // Transfer the meta lp token to the caller\n        metaLPToken.safeTransfer(msg.sender, metaLPTokenAmount);\n\n        return metaLPTokenAmount;\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     *        acceptable for this burn. Useful as a front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * @return amounts of tokens user received\n     */\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory) {\n        IERC20[] memory memBaseTokens = baseTokens;\n        IERC20[] memory memMetaTokens = metaTokens;\n        uint256[] memory totalRemovedAmounts;\n\n        {\n            uint256 numOfAllTokens =\n                memBaseTokens.length + memMetaTokens.length - 1;\n            require(minAmounts.length == numOfAllTokens, \"out of range\");\n            totalRemovedAmounts = new uint256[](numOfAllTokens);\n        }\n\n        // Transfer meta lp token from the caller to this\n        metaLPToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 baseLPTokenAmount;\n        {\n            // Remove liquidity from the meta swap pool\n            uint256[] memory removedAmounts;\n            uint256 baseLPTokenIndex = memMetaTokens.length - 1;\n            {\n                uint256[] memory metaMinAmounts =\n                    new uint256[](memMetaTokens.length);\n                for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n                    metaMinAmounts[i] = minAmounts[i];\n                }\n                removedAmounts = metaSwap.removeLiquidity(\n                    amount,\n                    metaMinAmounts,\n                    deadline\n                );\n            }\n\n            // Send the meta level tokens to the caller\n            for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n                totalRemovedAmounts[i] = removedAmounts[i];\n                memMetaTokens[i].safeTransfer(msg.sender, removedAmounts[i]);\n            }\n            baseLPTokenAmount = removedAmounts[baseLPTokenIndex];\n\n            // Remove liquidity from the base swap pool\n            {\n                uint256[] memory baseMinAmounts =\n                    new uint256[](memBaseTokens.length);\n                for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n                    baseMinAmounts[i] = minAmounts[baseLPTokenIndex + i];\n                }\n                removedAmounts = baseSwap.removeLiquidity(\n                    baseLPTokenAmount,\n                    baseMinAmounts,\n                    deadline\n                );\n            }\n\n            // Send the base level tokens to the caller\n            for (uint8 i = 0; i < memBaseTokens.length; i++) {\n                totalRemovedAmounts[baseLPTokenIndex + i] = removedAmounts[i];\n                memBaseTokens[i].safeTransfer(msg.sender, removedAmounts[i]);\n            }\n        }\n\n        return totalRemovedAmounts;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param tokenAmount the amount of the token you want to receive\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of chosen token user received\n     */\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256) {\n        uint8 baseLPTokenIndex = uint8(metaTokens.length - 1);\n        uint8 baseTokensLength = uint8(baseTokens.length);\n\n        metaLPToken.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        IERC20 token;\n        if (tokenIndex < baseLPTokenIndex) {\n            metaSwap.removeLiquidityOneToken(\n                tokenAmount,\n                tokenIndex,\n                minAmount,\n                deadline\n            );\n            token = metaTokens[tokenIndex];\n        } else if (tokenIndex < baseLPTokenIndex + baseTokensLength) {\n            uint256 removedBaseLPTokenAmount =\n                metaSwap.removeLiquidityOneToken(\n                    tokenAmount,\n                    baseLPTokenIndex,\n                    0,\n                    deadline\n                );\n\n            baseSwap.removeLiquidityOneToken(\n                removedBaseLPTokenAmount,\n                tokenIndex - baseLPTokenIndex,\n                minAmount,\n                deadline\n            );\n            token = baseTokens[tokenIndex - baseLPTokenIndex];\n        } else {\n            revert(\"out of range\");\n        }\n\n        uint256 amountWithdrawn = token.balanceOf(address(this));\n        token.safeTransfer(msg.sender, amountWithdrawn);\n        return amountWithdrawn;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP tokens burned\n     */\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256) {\n        IERC20[] memory memBaseTokens = baseTokens;\n        IERC20[] memory memMetaTokens = metaTokens;\n        uint256[] memory metaAmounts = new uint256[](memMetaTokens.length);\n        uint256[] memory baseAmounts = new uint256[](memBaseTokens.length);\n\n        require(\n            amounts.length == memBaseTokens.length + memMetaTokens.length - 1,\n            \"out of range\"\n        );\n\n        RemoveLiquidityImbalanceInfo memory v =\n            RemoveLiquidityImbalanceInfo(\n                baseSwap,\n                metaSwap,\n                metaLPToken,\n                uint8(metaAmounts.length - 1),\n                false,\n                0\n            );\n\n        for (uint8 i = 0; i < v.baseLPTokenIndex; i++) {\n            metaAmounts[i] = amounts[i];\n        }\n\n        for (uint8 i = 0; i < baseAmounts.length; i++) {\n            baseAmounts[i] = amounts[v.baseLPTokenIndex + i];\n            if (baseAmounts[i] > 0) {\n                v.withdrawFromBase = true;\n            }\n        }\n\n        // Calculate how much base LP token we need to get the desired amount of underlying tokens\n        if (v.withdrawFromBase) {\n            metaAmounts[v.baseLPTokenIndex] = v\n                .baseSwap\n                .calculateTokenAmount(address(this), baseAmounts, false)\n                .mul(10005)\n                .div(10000);\n        }\n\n        // Transfer meta swap LP token from the caller to this contract\n        v.metaLPToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            maxBurnAmount\n        );\n\n        // Withdraw the paired meta level tokens and the base LP token from the meta swap pool\n        uint256 burnedMetaLPTokenAmount =\n            v.metaSwap.removeLiquidityImbalance(\n                metaAmounts,\n                maxBurnAmount,\n                deadline\n            );\n        v.leftoverMetaLPTokenAmount = maxBurnAmount.sub(\n            burnedMetaLPTokenAmount\n        );\n\n        // If underlying tokens are desired, withdraw them from the base swap pool\n        if (v.withdrawFromBase) {\n            v.baseSwap.removeLiquidityImbalance(\n                baseAmounts,\n                metaAmounts[v.baseLPTokenIndex],\n                deadline\n            );\n\n            // Base swap may require LESS base LP token than the amount we have\n            // In that case, deposit it to the meta swap pool.\n            uint256[] memory leftovers = new uint256[](metaAmounts.length);\n            IERC20 baseLPToken = memMetaTokens[v.baseLPTokenIndex];\n            uint256 leftoverBaseLPTokenAmount =\n                baseLPToken.balanceOf(address(this));\n            if (leftoverBaseLPTokenAmount > 0) {\n                leftovers[v.baseLPTokenIndex] = leftoverBaseLPTokenAmount;\n                v.leftoverMetaLPTokenAmount = v.leftoverMetaLPTokenAmount.add(\n                    v.metaSwap.addLiquidity(leftovers, 0, deadline)\n                );\n            }\n        }\n\n        // Transfer all withdrawn tokens to the caller\n        for (uint8 i = 0; i < amounts.length; i++) {\n            IERC20 token;\n            if (i < v.baseLPTokenIndex) {\n                token = memMetaTokens[i];\n            } else {\n                token = memBaseTokens[i - v.baseLPTokenIndex];\n            }\n            if (amounts[i] > 0) {\n                token.safeTransfer(msg.sender, amounts[i]);\n            }\n        }\n\n        // If there were any extra meta lp token, transfer them back to the caller as well\n        if (v.leftoverMetaLPTokenAmount > 0) {\n            v.metaLPToken.safeTransfer(msg.sender, v.leftoverMetaLPTokenAmount);\n        }\n\n        return maxBurnAmount - v.leftoverMetaLPTokenAmount;\n    }\n\n    // VIEW FUNCTIONS\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running. When withdrawing from the base pool in imbalanced\n     * fashion, the recommended slippage setting is 0.2% or higher.\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param account address that is depositing or withdrawing tokens\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256) {\n        account = address(this);\n        uint256[] memory metaAmounts = new uint256[](metaTokens.length);\n        uint256[] memory baseAmounts = new uint256[](baseTokens.length);\n        uint256 baseLPTokenIndex = metaAmounts.length - 1;\n\n        for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n            metaAmounts[i] = amounts[i];\n        }\n\n        for (uint8 i = 0; i < baseAmounts.length; i++) {\n            baseAmounts[i] = amounts[baseLPTokenIndex + i];\n        }\n\n        uint256 baseLPTokenAmount =\n            baseSwap.calculateTokenAmount(account, baseAmounts, deposit);\n        metaAmounts[baseLPTokenIndex] = baseLPTokenAmount;\n\n        return metaSwap.calculateTokenAmount(account, metaAmounts, deposit);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of LP tokens\n     * @param account the address that is withdrawing tokens\n     * @param amount the amount of LP tokens that would be burned on withdrawal\n     * @return array of token balances that the user will receive\n     */\n    function calculateRemoveLiquidity(address account, uint256 amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        account = address(this); // overwrite account\n        uint256[] memory metaAmounts =\n            metaSwap.calculateRemoveLiquidity(account, amount);\n        uint8 baseLPTokenIndex = uint8(metaAmounts.length - 1);\n        uint256[] memory baseAmounts =\n            baseSwap.calculateRemoveLiquidity(\n                account,\n                metaAmounts[baseLPTokenIndex]\n            );\n\n        uint256[] memory totalAmounts =\n            new uint256[](baseLPTokenIndex + baseAmounts.length);\n        for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n            totalAmounts[i] = metaAmounts[i];\n        }\n        for (uint8 i = 0; i < baseAmounts.length; i++) {\n            totalAmounts[baseLPTokenIndex + i] = baseAmounts[i];\n        }\n\n        return totalAmounts;\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param account the address that is withdrawing tokens\n     * @param tokenAmount the amount of LP token to burn\n     * @param tokenIndex index of which token will be withdrawn\n     * @return availableTokenAmount calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256) {\n        account = address(this); // overwrite account\n        uint8 baseLPTokenIndex = uint8(metaTokens.length - 1);\n\n        if (tokenIndex < baseLPTokenIndex) {\n            return\n                metaSwap.calculateRemoveLiquidityOneToken(\n                    account,\n                    tokenAmount,\n                    tokenIndex\n                );\n        } else {\n            uint256 baseLPTokenAmount =\n                metaSwap.calculateRemoveLiquidityOneToken(\n                    account,\n                    tokenAmount,\n                    baseLPTokenIndex\n                );\n            return\n                baseSwap.calculateRemoveLiquidityOneToken(\n                    account,\n                    baseLPTokenAmount,\n                    tokenIndex - baseLPTokenIndex\n                );\n        }\n    }\n\n    /**\n     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n     * This is a flattened representation of the pooled tokens.\n     * @param index the index of the token\n     * @return address of the token at given index\n     */\n    function getToken(uint256 index) external view returns (IERC20) {\n        require(index < tokens.length, \"index out of range\");\n        return tokens[index];\n    }\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256) {\n        return\n            metaSwap.calculateSwapUnderlying(tokenIndexFrom, tokenIndexTo, dx);\n    }\n}"
    },
    "contracts/stable/IMetaSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMetaSwap {\n    // pool data view functions\n    function getA() external view returns (uint256);\n\n    function getToken(uint8 index) external view returns (IERC20);\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function getVirtualPrice() external view returns (uint256);\n\n    function isGuarded() external view returns (bool);\n\n    function swapStorage()\n        external\n        view\n        returns (\n            uint256 initialA,\n            uint256 futureA,\n            uint256 initialATime,\n            uint256 futureATime,\n            uint256 swapFee,\n            uint256 adminFee,\n            uint256 defaultDepositFee,\n            uint256 defaultWithdrawFee,\n            address lpToken,\n            address devaddr\n        );\n\n    // min return calculation functions\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateSwapUnderlying(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateTokenAmount(\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidity(address account, uint256 amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function swapUnderlying(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // withdraw fee update function\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\n        external;\n}"
    },
    "contracts/stable/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface ISwap {\n    // pool data view functions\n    function getA() external view returns (uint256);\n\n    function getToken(uint8 index) external view returns (IERC20);\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function getVirtualPrice() external view returns (uint256);\n\n    // min return calculation functions\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateTokenAmount(\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidity(address account, uint256 amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // withdraw fee update function\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\n        external;\n}"
    },
    "contracts/stable/MetaSwapUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./MathUtils.sol\";\nimport \"./ISwap.sol\";\nimport \"./EvmoSwapUtils.sol\";\nimport \"./LPToken.sol\";\n\n\n/**\n * @title MetaSwapUtils library\n * @notice A library to be used within MetaSwap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize EvmoSwapUtils.Swap struct then use this library\n * for EvmoSwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary MetaSwapUtils {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using MathUtils for uint256;\n\n    /*** EVENTS ***/\n\n    event TokenSwap(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n    event TokenSwapUnderlying(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n\n    struct MetaSwap {\n        // Meta-Swap related parameters\n        ISwap baseSwap;\n        uint256 baseVirtualPrice;\n        uint256 baseCacheLastUpdated;\n        IERC20[] baseTokens;\n    }\n\n    // Struct storing variables used in calculations in the\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n    struct CalculateWithdrawOneTokenDYInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 newY;\n        uint256 feePerToken;\n        uint256 preciseA;\n        uint256 xpi;\n    }\n\n    // Struct storing variables used in calculation in removeLiquidityImbalance function\n    // to avoid stack too deep error\n    struct ManageLiquidityInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 d2;\n        LPToken lpToken;\n        uint256 totalSupply;\n        uint256 preciseA;\n        uint256 baseVirtualPrice;\n        uint256[] tokenPrecisionMultipliers;\n        uint256[] newBalances;\n    }\n\n    struct SwapUnderlyingInfo {\n        uint256 x;\n        uint256 dx;\n        uint256 dy;\n        uint8 metaIndexFrom;\n        uint8 metaIndexTo;\n        uint256[] oldBalances;\n        IERC20[] baseTokens;\n        IERC20 tokenFrom;\n        IERC20 tokenTo;\n        uint256 baseVirtualPrice;\n    }\n\n    struct CalculateSwapUnderlyingInfo {\n        uint256 baseVirtualPrice;\n        ISwap baseSwap;\n        uint8 baseLPTokenIndex;\n        uint8 baseTokensLength;\n        uint8 metaIndexTo;\n        uint256 x;\n        uint256 dy;\n    }\n\n    // the precision all pools tokens will be converted to\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\n\n    // the denominator used to calculate admin and LP fees. For example, an\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n\n    // Constant value used as max loop limit\n    uint256 private constant MAX_LOOP_LIMIT = 256;\n\n    // Precision used in A parameter calculation\n    uint256 public constant A_PRECISION = 100;\n\n    // Cache expire time for the stored value of base swap's virtual price\n    uint256 public constant BASE_CACHE_EXPIRE_TIME = 10 minutes;\n    uint256 public constant BASE_VIRTUAL_PRICE_PRECISION = 10**18;\n\n    /*** VIEW & PURE FUNCTIONS ***/\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise(EvmoSwapUtils.Swap storage self)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 t1 = self.futureATime; // time when ramp is finished\n        uint256 a1 = self.futureA; // final A value when ramp is finished\n\n        if (block.timestamp < t1) {\n            uint256 t0 = self.initialATime; // time when ramp is started\n            uint256 a0 = self.initialA; // initial A value when ramp is started\n            if (a1 > a0) {\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\n                return\n                    a0.add(\n                        a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\n                    );\n            } else {\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\n                return\n                    a0.sub(\n                        a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\n                    );\n            }\n        } else {\n            return a1;\n        }\n    }\n\n    function _updateBaseVirtualPrice(MetaSwap storage metaSwapStorage)\n        internal\n        returns (uint256)\n    {\n        if (\n            block.timestamp >\n            metaSwapStorage.baseCacheLastUpdated + BASE_CACHE_EXPIRE_TIME\n        ) {\n            uint256 baseVirtualPrice =\n                ISwap(metaSwapStorage.baseSwap).getVirtualPrice();\n            metaSwapStorage.baseVirtualPrice = baseVirtualPrice;\n            metaSwapStorage.baseCacheLastUpdated = block.timestamp;\n            return baseVirtualPrice;\n        } else {\n            return metaSwapStorage.baseVirtualPrice;\n        }\n    }\n\n    function _getBaseVirtualPrice(\n        MetaSwap storage metaSwapStorage,\n        ISwap baseSwap\n    ) internal view returns (uint256) {\n        if (\n            block.timestamp >\n            metaSwapStorage.baseCacheLastUpdated + BASE_CACHE_EXPIRE_TIME\n        ) {\n            return baseSwap.getVirtualPrice();\n        } else {\n            return metaSwapStorage.baseVirtualPrice;\n        }\n    }\n\n    function _getBaseVirtualPrice(MetaSwap storage metaSwapStorage)\n        internal\n        view\n        returns (uint256)\n    {\n        return _getBaseVirtualPrice(metaSwapStorage, metaSwapStorage.baseSwap);\n    }\n\n    /**\n     * @notice Calculate the dy, the amount of selected token that user receives.\n     * @param account the address that is withdrawing\n     * @param tokenAmount the amount to withdraw in the pool's precision\n     * @param tokenIndex which token will be withdrawn\n     * @param self Swap struct to read from\n     * @return dy the amount of token user will receive\n     */\n    function calculateWithdrawOneToken(\n        EvmoSwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 dy) {\n        (dy, ) = calculateWithdrawOneToken(\n            self,\n            account,\n            tokenAmount,\n            tokenIndex,\n            _getBaseVirtualPrice(metaSwapStorage),\n            self.lpToken.totalSupply()\n        );\n    }\n\n    function calculateWithdrawOneToken(\n        EvmoSwapUtils.Swap storage self,\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 baseVirtualPrice,\n        uint256 totalSupply\n    ) internal view returns (uint256, uint256) {\n        uint256 dy;\n        uint256 dySwapFee;\n\n        {\n            uint256 currentY;\n            uint256 newY;\n\n            (dy, newY, currentY) = calculateWithdrawOneTokenDY(\n                self,\n                tokenIndex,\n                tokenAmount,\n                baseVirtualPrice,\n                totalSupply\n            );\n\n            dySwapFee = currentY\n                .sub(newY)\n                .div(self.tokenPrecisionMultipliers[tokenIndex])\n                .sub(dy);\n        }\n\n        dy = dy\n            .mul(\n            FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, account))\n        )\n            .div(FEE_DENOMINATOR);\n\n        return (dy, dySwapFee);\n    }\n\n    /**\n     * @notice Calculate the dy of withdrawing in one token\n     * @param self Swap struct to read from\n     * @param tokenIndex which token will be withdrawn\n     * @param tokenAmount the amount to withdraw in the pools precision\n     * @return the d and the new y after withdrawing one token\n     */\n    function calculateWithdrawOneTokenDY(\n        EvmoSwapUtils.Swap storage self,\n        uint8 tokenIndex,\n        uint256 tokenAmount,\n        uint256 baseVirtualPrice,\n        uint256 totalSupply\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the current D, then solve the stableswap invariant\n        // y_i for D - tokenAmount\n        uint256[] memory xp = _xp(self, baseVirtualPrice);\n        require(tokenIndex < xp.length, \"Token index out of range\");\n\n        CalculateWithdrawOneTokenDYInfo memory v =\n            CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0, 0);\n        v.preciseA = getAPrecise(self);\n        v.d0 = getD(xp, v.preciseA);\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\n\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\n\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\n\n        uint256[] memory xpReduced = new uint256[](xp.length);\n\n        v.feePerToken = _feePerToken(self);\n        for (uint256 i = 0; i < xp.length; i++) {\n            v.xpi = xp[i];\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\n            xpReduced[i] = v.xpi.sub(\n                (\n                    (i == tokenIndex)\n                        ? v.xpi.mul(v.d1).div(v.d0).sub(v.newY)\n                        : v.xpi.sub(v.xpi.mul(v.d1).div(v.d0))\n                )\n                    .mul(v.feePerToken)\n                    .div(FEE_DENOMINATOR)\n            );\n        }\n\n        uint256 dy =\n            xpReduced[tokenIndex].sub(\n                getYD(v.preciseA, tokenIndex, xpReduced, v.d1)\n            );\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\n\n        if (tokenIndex == xp.length - 1) {\n            dy = dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(baseVirtualPrice);\n        }\n\n        return (dy, v.newY, xp[tokenIndex]);\n    }\n\n    /**\n     * @notice Calculate the price of a token in the pool with given\n     * precision-adjusted balances and a particular D.\n     *\n     * @dev This is accomplished via solving the invariant iteratively.\n     * See the StableSwap paper and Curve.fi implementation for further details.\n     *\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n     * x_1**2 + b*x_1 = c\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\n     *\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n     * @param tokenIndex Index of token we are calculating for.\n     * @param xp a precision-adjusted set of pool balances. Array should be\n     * the same cardinality as the pool.\n     * @param d the stableswap invariant\n     * @return the price of the token, in the same precision as in xp\n     */\n    function getYD(\n        uint256 a,\n        uint8 tokenIndex,\n        uint256[] memory xp,\n        uint256 d\n    ) internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = a.mul(numTokens);\n\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i != tokenIndex) {\n                s = s.add(xp[i]);\n                c = c.mul(d).div(xp[i].mul(numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // c = c * D * D * D * ... overflow!\n            }\n        }\n        c = c.mul(d).mul(A_PRECISION).div(nA.mul(numTokens));\n\n        uint256 b = s.add(d.mul(A_PRECISION).div(nA));\n        uint256 yPrev;\n        uint256 y = d;\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n     * as the pool.\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n     * See the StableSwap paper for details\n     * @return the invariant, at the precision of the pool\n     */\n    function getD(uint256[] memory xp, uint256 a)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 numTokens = xp.length;\n        uint256 s;\n        for (uint256 i = 0; i < numTokens; i++) {\n            s = s.add(xp[i]);\n        }\n        if (s == 0) {\n            return 0;\n        }\n\n        uint256 prevD;\n        uint256 d = s;\n        uint256 nA = a.mul(numTokens);\n\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            uint256 dP = d;\n            for (uint256 j = 0; j < numTokens; j++) {\n                dP = dP.mul(d).div(xp[j].mul(numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // dP = dP * D * D * D * ... overflow!\n            }\n            prevD = d;\n            d = nA.mul(s).div(A_PRECISION).add(dP.mul(numTokens)).mul(d).div(\n                nA.sub(A_PRECISION).mul(d).div(A_PRECISION).add(\n                    numTokens.add(1).mul(dP)\n                )\n            );\n            if (d.within1(prevD)) {\n                return d;\n            }\n        }\n\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n        // function which does not rely on D.\n        revert(\"D does not converge\");\n    }\n\n    /**\n     * @notice Given a set of balances and precision multipliers, return the\n     * precision-adjusted balances.\n     *\n     * @param balances an array of token balances, in their native precisions.\n     * These should generally correspond with pooled tokens.\n     *\n     * @param precisionMultipliers an array of multipliers, corresponding to\n     * the amounts in the balances array. When multiplied together they\n     * should yield amounts at the pool's precision.\n     *\n     * @return an array of amounts \"scaled\" to the pool's precision\n     */\n    function _xp(\n        uint256[] memory balances,\n        uint256[] memory precisionMultipliers,\n        uint256 baseVirtualPrice\n    ) internal pure returns (uint256[] memory) {\n        uint256 numTokens = balances.length;\n        require(\n            numTokens == precisionMultipliers.length,\n            \"Balances must match multipliers\"\n        );\n        uint256[] memory xp = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; i++) {\n            xp[i] = balances[i].mul(precisionMultipliers[i]);\n        }\n        uint256 baseLPTokenIndex = numTokens - 1;\n        xp[baseLPTokenIndex] = xp[baseLPTokenIndex].mul(baseVirtualPrice).div(\n            BASE_VIRTUAL_PRICE_PRECISION\n        );\n        return xp;\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @param self Swap struct to read from\n     * @param balances array of balances to scale\n     * @return balances array \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(\n        EvmoSwapUtils.Swap storage self,\n        uint256[] memory balances,\n        uint256 baseVirtualPrice\n    ) internal view returns (uint256[] memory) {\n        return _xp(balances, self.tokenPrecisionMultipliers, baseVirtualPrice);\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @param self Swap struct to read from\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(EvmoSwapUtils.Swap storage self, uint256 baseVirtualPrice)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        return\n            _xp(\n                self.balances,\n                self.tokenPrecisionMultipliers,\n                baseVirtualPrice\n            );\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @param self Swap struct to read from\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice(\n        EvmoSwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage\n    ) external view returns (uint256) {\n        uint256 d =\n            getD(\n                _xp(self, _getBaseVirtualPrice(metaSwapStorage)),\n                getAPrecise(self)\n            );\n        ERC20 lpToken = self.lpToken;\n        uint256 supply = lpToken.totalSupply();\n        if (supply != 0) {\n            return d.mul(10**uint256(lpToken.decimals())).div(supply);\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Calculate the new balances of the tokens given the indexes of the token\n     * that is swapped from (FROM) and the token that is swapped to (TO).\n     * This function is used as a helper function to calculate how much TO token\n     * the user should receive on swap.\n     *\n     * @param preciseA value of A parameter to use for calculation\n     * @param tokenIndexFrom index of FROM token\n     * @param tokenIndexTo index of TO token\n     * @param x the new total amount of FROM token\n     * @param xp balances of the tokens in the pool\n     * @return the amount of TO token that should remain in the pool\n     */\n    function getY(\n        uint256 preciseA,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 x,\n        uint256[] memory xp\n    ) internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(\n            tokenIndexFrom != tokenIndexTo,\n            \"Can't compare token to itself\"\n        );\n        require(\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\n            \"Tokens must be in pool\"\n        );\n\n        uint256 d = getD(xp, preciseA);\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = numTokens.mul(preciseA);\n\n        uint256 _x;\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i == tokenIndexFrom) {\n                _x = x;\n            } else if (i != tokenIndexTo) {\n                _x = xp[i];\n            } else {\n                continue;\n            }\n            s = s.add(_x);\n            c = c.mul(d).div(_x.mul(numTokens));\n            // If we were to protect the division loss we would have to keep the denominator separate\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\n            // c = c * D * D * D * ... overflow!\n        }\n        c = c.mul(d).mul(A_PRECISION).div(nA.mul(numTokens));\n        uint256 b = s.add(d.mul(A_PRECISION).div(nA));\n        uint256 yPrev;\n        uint256 y = d;\n\n        // iterative approximation\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Externally calculates a swap between two tokens.\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     */\n    function calculateSwap(\n        EvmoSwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 dy) {\n        (dy, ) = _calculateSwap(\n            self,\n            tokenIndexFrom,\n            tokenIndexTo,\n            dx,\n            _getBaseVirtualPrice(metaSwapStorage)\n        );\n    }\n\n    /**\n     * @notice Internally calculates a swap between two tokens.\n     *\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\n     * using the token contracts.\n     *\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     * @return dyFee the associated fee\n     */\n    function _calculateSwap(\n        EvmoSwapUtils.Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 baseVirtualPrice\n    ) internal view returns (uint256 dy, uint256 dyFee) {\n        uint256[] memory xp = _xp(self, baseVirtualPrice);\n        require(\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\n            \"Token index out of range\"\n        );\n        uint256 x =\n            dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]).add(\n                xp[tokenIndexFrom]\n            );\n        uint256 y =\n            getY(getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\n        dy = xp[tokenIndexTo].sub(y).sub(1);\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n        dy = dy.sub(dyFee).div(self.tokenPrecisionMultipliers[tokenIndexTo]);\n    }\n\n    function calculateSwapUnderlying(\n        EvmoSwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256) {\n        CalculateSwapUnderlyingInfo memory v =\n            CalculateSwapUnderlyingInfo(\n                _getBaseVirtualPrice(metaSwapStorage),\n                metaSwapStorage.baseSwap,\n                0,\n                uint8(metaSwapStorage.baseTokens.length),\n                0,\n                0,\n                0\n            );\n\n        uint256[] memory xp = _xp(self, v.baseVirtualPrice);\n        v.baseLPTokenIndex = uint8(xp.length) - 1;\n        {\n            uint8 maxRange = v.baseLPTokenIndex + v.baseTokensLength;\n            require(\n                tokenIndexFrom < maxRange && tokenIndexTo < maxRange,\n                \"Token index out of range\"\n            );\n        }\n\n        if (tokenIndexFrom < v.baseLPTokenIndex) {\n            // tokenFrom is from this pool\n            v.x = xp[tokenIndexFrom].add(\n                dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom])\n            );\n        } else {\n            // tokenFrom is from the base pool\n            tokenIndexFrom = tokenIndexFrom - v.baseLPTokenIndex;\n            if (tokenIndexTo < v.baseLPTokenIndex) {\n                uint256[] memory baseInputs = new uint256[](v.baseTokensLength);\n                baseInputs[tokenIndexFrom] = dx;\n                v.x = v\n                    .baseSwap\n                    .calculateTokenAmount(address(this), baseInputs, true)\n                    .mul(v.baseVirtualPrice)\n                    .div(BASE_VIRTUAL_PRICE_PRECISION)\n                    .add(xp[v.baseLPTokenIndex]);\n            } else {\n                // both from and to are from the base pool\n                return\n                    v.baseSwap.calculateSwap(\n                        tokenIndexFrom,\n                        tokenIndexTo - v.baseLPTokenIndex,\n                        dx\n                    );\n            }\n            tokenIndexFrom = v.baseLPTokenIndex;\n        }\n\n        v.metaIndexTo = v.baseLPTokenIndex;\n        if (tokenIndexTo < v.baseLPTokenIndex) {\n            v.metaIndexTo = tokenIndexTo;\n        }\n\n        {\n            uint256 y =\n                getY(getAPrecise(self), tokenIndexFrom, v.metaIndexTo, v.x, xp);\n            v.dy = xp[v.metaIndexTo].sub(y).sub(1);\n            uint256 dyFee = v.dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n            v.dy = v.dy.sub(dyFee);\n        }\n\n        if (tokenIndexTo < v.baseLPTokenIndex) {\n            // tokenTo is from this pool\n            v.dy = v.dy.div(self.tokenPrecisionMultipliers[v.metaIndexTo]);\n        } else {\n            // tokenTo is from the base pool\n            v.dy = v.baseSwap.calculateRemoveLiquidityOneToken(\n                address(this),\n                v.dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(v.baseVirtualPrice),\n                tokenIndexTo - v.baseLPTokenIndex\n            );\n        }\n\n        return v.dy;\n    }\n\n    /**\n     * @notice Calculate the fee that is applied when the given user withdraws.\n     * Withdraw fee decays linearly over 4 weeks.\n     * @param user address you want to calculate withdraw fee of\n     * @return current withdraw fee of the user\n     */\n    function calculateCurrentWithdrawFee(\n        EvmoSwapUtils.Swap storage self,\n        address user\n    ) public view returns (uint256) {\n        uint256 endTime = self.depositTimestamp[user].add(4 weeks);\n        if (endTime > block.timestamp) {\n            uint256 timeLeftover = endTime.sub(block.timestamp);\n            return\n                self\n                    .defaultWithdrawFee\n                    .mul(self.withdrawFeeMultiplier[user])\n                    .mul(timeLeftover)\n                    .div(4 weeks)\n                    .div(FEE_DENOMINATOR);\n        }\n        return 0;\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param self Swap struct to read from\n     * @param account address of the account depositing or withdrawing tokens\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return if deposit was true, total amount of lp token that will be minted and if\n     * deposit was false, total amount of lp token that will be burned\n     */\n    function calculateTokenAmount(\n        EvmoSwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256) {\n        uint256 a = getAPrecise(self);\n        uint256 d0;\n        uint256 d1;\n        {\n            uint256 baseVirtualPrice = _getBaseVirtualPrice(metaSwapStorage);\n            uint256[] memory balances1 = self.balances;\n            uint256 numTokens = balances1.length;\n            d0 = getD(_xp(self, balances1, baseVirtualPrice), a);\n            for (uint256 i = 0; i < numTokens; i++) {\n                if (deposit) {\n                    balances1[i] = balances1[i].add(amounts[i]);\n                } else {\n                    balances1[i] = balances1[i].sub(\n                        amounts[i],\n                        \"Cannot withdraw more than available\"\n                    );\n                }\n            }\n            d1 = getD(_xp(self, balances1, baseVirtualPrice), a);\n        }\n        uint256 totalSupply = self.lpToken.totalSupply();\n\n        if (deposit) {\n            return d1.sub(d0).mul(totalSupply).div(d0);\n        } else {\n            return\n                d0.sub(d1).mul(totalSupply).div(d0).mul(FEE_DENOMINATOR).div(\n                    FEE_DENOMINATOR.sub(\n                        calculateCurrentWithdrawFee(self, account)\n                    )\n                );\n        }\n    }\n\n    /**\n     * @notice internal helper function to calculate fee per token multiplier used in\n     * swap fee calculations\n     * @param self Swap struct to read from\n     */\n    function _feePerToken(EvmoSwapUtils.Swap storage self)\n        internal\n        view\n        returns (uint256)\n    {\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        return\n            self.swapFee.mul(pooledTokens.length).div(\n                pooledTokens.length.sub(1).mul(4)\n            );\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice swap two tokens in the pool\n     * @param self Swap struct to read from and write to\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @return amount of token user received on swap\n     */\n    function swap(\n        EvmoSwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy\n    ) external returns (uint256) {\n        uint256 transferredDx;\n        {\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n            require(\n                dx <= tokenFrom.balanceOf(msg.sender),\n                \"Cannot swap more than you own\"\n            );\n\n            {\n                // Transfer tokens first to see if a fee was charged on transfer\n                uint256 beforeBalance = tokenFrom.balanceOf(address(this));\n                tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n\n                // Use the actual transferred amount for AMM math\n                transferredDx = tokenFrom.balanceOf(address(this)).sub(\n                    beforeBalance\n                );\n            }\n        }\n\n        (uint256 dy, uint256 dyFee) =\n            _calculateSwap(\n                self,\n                tokenIndexFrom,\n                tokenIndexTo,\n                transferredDx,\n                _updateBaseVirtualPrice(metaSwapStorage)\n            );\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n        uint256 dyAdminFee =\n            dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n                self.tokenPrecisionMultipliers[tokenIndexTo]\n            );\n\n        self.balances[tokenIndexFrom] = self.balances[tokenIndexFrom].add(\n            transferredDx\n        );\n        self.balances[tokenIndexTo] = self.balances[tokenIndexTo].sub(dy).sub(\n            dyAdminFee\n        );\n\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n        emit TokenSwap(\n            msg.sender,\n            transferredDx,\n            dy,\n            tokenIndexFrom,\n            tokenIndexTo\n        );\n\n        return dy;\n    }\n\n    function swapUnderlying(\n        EvmoSwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy\n    ) external returns (uint256) {\n        SwapUnderlyingInfo memory v =\n            SwapUnderlyingInfo(\n                0,\n                0,\n                0,\n                0,\n                0,\n                self.balances,\n                metaSwapStorage.baseTokens,\n                IERC20(address(0)),\n                IERC20(address(0)),\n                _updateBaseVirtualPrice(metaSwapStorage)\n            );\n\n        uint8 baseLPTokenIndex = uint8(v.oldBalances.length) - 1;\n\n        {\n            uint8 maxRange = baseLPTokenIndex + uint8(v.baseTokens.length);\n            require(\n                tokenIndexFrom < maxRange && tokenIndexTo < maxRange,\n                \"Token index out of range\"\n            );\n        }\n\n        ISwap baseSwap = metaSwapStorage.baseSwap;\n\n        // Find the address of the token swapping from\n        if (tokenIndexFrom < baseLPTokenIndex) {\n            v.tokenFrom = self.pooledTokens[tokenIndexFrom];\n            v.metaIndexFrom = tokenIndexFrom;\n        } else {\n            v.tokenFrom = v.baseTokens[tokenIndexFrom - baseLPTokenIndex];\n            v.metaIndexFrom = baseLPTokenIndex;\n        }\n\n        // Find the address of the token swapping to\n        if (tokenIndexTo < baseLPTokenIndex) {\n            v.tokenTo = self.pooledTokens[tokenIndexTo];\n            v.metaIndexTo = tokenIndexTo;\n        } else {\n            v.tokenTo = v.baseTokens[tokenIndexTo - baseLPTokenIndex];\n            v.metaIndexTo = baseLPTokenIndex;\n        }\n\n        v.dx = v.tokenFrom.balanceOf(address(this));\n        v.tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n        v.dx = v.tokenFrom.balanceOf(address(this)).sub(v.dx); // update dx in case of fee on transfer\n\n        if (\n            tokenIndexFrom < baseLPTokenIndex || tokenIndexTo < baseLPTokenIndex\n        ) {\n            uint256[] memory xp = _xp(self, v.oldBalances, v.baseVirtualPrice);\n\n            if (tokenIndexFrom < baseLPTokenIndex) {\n                v.x =\n                    xp[tokenIndexFrom] +\n                    dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]);\n            } else {\n                // tokenFrom is in the base pool\n                uint256[] memory baseAmounts =\n                    new uint256[](v.baseTokens.length);\n                baseAmounts[tokenIndexFrom - baseLPTokenIndex] = v.dx;\n                IERC20 baseLPToken = self.pooledTokens[baseLPTokenIndex];\n                v.x = baseLPToken.balanceOf(address(this));\n                // Add liquidity to the underlying swap contract\n                baseSwap.addLiquidity(baseAmounts, 0, block.timestamp);\n                // Now we have more of the base LP token\n                v.dx = baseLPToken.balanceOf(address(this)).sub(v.x);\n                v.x = v\n                    .dx\n                    .mul(v.baseVirtualPrice)\n                    .div(BASE_VIRTUAL_PRICE_PRECISION)\n                    .add(xp[baseLPTokenIndex]);\n            }\n\n            uint256 dyFee;\n            {\n                uint256 y =\n                    getY(\n                        getAPrecise(self),\n                        v.metaIndexFrom,\n                        v.metaIndexTo,\n                        v.x,\n                        xp\n                    );\n                v.dy = xp[v.metaIndexTo].sub(y).sub(1);\n                dyFee = v.dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n                v.dy = v.dy.sub(dyFee).div(\n                    self.tokenPrecisionMultipliers[v.metaIndexTo]\n                );\n            }\n\n            if (tokenIndexTo >= baseLPTokenIndex) {\n                v.dy = v.dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(\n                    v.baseVirtualPrice\n                );\n            }\n\n            {\n                uint256 dyAdminFee =\n                    dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);\n                dyAdminFee = dyAdminFee.div(\n                    self.tokenPrecisionMultipliers[v.metaIndexTo]\n                );\n                self.balances[v.metaIndexFrom] = v.oldBalances[v.metaIndexFrom]\n                    .add(v.dx);\n                self.balances[v.metaIndexTo] = v.oldBalances[v.metaIndexTo]\n                    .sub(v.dy)\n                    .sub(dyAdminFee);\n            }\n\n            if (tokenIndexTo >= baseLPTokenIndex) {\n                // tokenTo is from the base pool\n                // burn the LP token and withdraw the desired token from the base pool\n                uint256 oldBalance = v.tokenTo.balanceOf(address(this));\n                baseSwap.removeLiquidityOneToken(\n                    v.dy,\n                    tokenIndexTo - baseLPTokenIndex,\n                    0,\n                    block.timestamp\n                );\n                v.dy = v.tokenTo.balanceOf(address(this)) - oldBalance;\n            }\n            require(v.dy >= minDy, \"Swap didn't result in min tokens\");\n        } else {\n            // Both tokens are from the base swap pool\n            v.dy = v.tokenTo.balanceOf(address(this));\n            baseSwap.swap(\n                tokenIndexFrom - baseLPTokenIndex,\n                tokenIndexTo - baseLPTokenIndex,\n                v.dx,\n                minDy,\n                block.timestamp\n            );\n            v.dy = v.tokenTo.balanceOf(address(this)).sub(v.dy);\n        }\n\n        v.tokenTo.safeTransfer(msg.sender, v.dy);\n\n        emit TokenSwapUnderlying(\n            msg.sender,\n            dx,\n            v.dy,\n            tokenIndexFrom,\n            tokenIndexTo\n        );\n\n        return v.dy;\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param self Swap struct to read from and write to\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n     * @return amount of LP token user received\n     */\n    function addLiquidity(\n        EvmoSwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256[] memory amounts,\n        uint256 minToMint\n    ) external returns (uint256) {\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        require(\n            amounts.length == self.pooledTokens.length,\n            \"Amounts must match pooled tokens\"\n        );\n\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n\n        // current state\n        ManageLiquidityInfo memory v =\n            ManageLiquidityInfo(\n                0,\n                0,\n                0,\n                self.lpToken,\n                0,\n                getAPrecise(self),\n                _updateBaseVirtualPrice(metaSwapStorage),\n                self.tokenPrecisionMultipliers,\n                self.balances\n            );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        if (v.totalSupply != 0) {\n            v.d0 = getD(\n                _xp(\n                    v.newBalances,\n                    v.tokenPrecisionMultipliers,\n                    v.baseVirtualPrice\n                ),\n                v.preciseA\n            );\n        }\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            require(\n                v.totalSupply != 0 || amounts[i] > 0,\n                \"Must supply all tokens in pool\"\n            );\n\n            // Transfer tokens first to see if a fee was charged on transfer\n            if (amounts[i] != 0) {\n                uint256 beforeBalance =\n                    pooledTokens[i].balanceOf(address(this));\n                pooledTokens[i].safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amounts[i]\n                );\n\n                // Update the amounts[] with actual transfer amount\n                amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(\n                    beforeBalance\n                );\n            }\n\n            v.newBalances[i] = v.newBalances[i].add(amounts[i]);\n        }\n\n        // invariant after change\n        v.d1 = getD(\n            _xp(v.newBalances, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n            v.preciseA\n        );\n        require(v.d1 > v.d0, \"D should increase\");\n\n        // updated to reflect fees and calculate the user's LP tokens\n        v.d2 = v.d1;\n        uint256 toMint;\n\n        if (v.totalSupply != 0) {\n            uint256 feePerToken = _feePerToken(self);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n                fees[i] = feePerToken\n                    .mul(idealBalance.difference(v.newBalances[i]))\n                    .div(FEE_DENOMINATOR);\n                self.balances[i] = v.newBalances[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                v.newBalances[i] = v.newBalances[i].sub(fees[i]);\n            }\n            v.d2 = getD(\n                _xp(\n                    v.newBalances,\n                    v.tokenPrecisionMultipliers,\n                    v.baseVirtualPrice\n                ),\n                v.preciseA\n            );\n            toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);\n        } else {\n            // the initial depositor doesn't pay fees\n            self.balances = v.newBalances;\n            toMint = v.d1;\n        }\n\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\n\n        // mint the user's LP tokens\n        self.lpToken.mint(msg.sender, toMint);\n\n        emit AddLiquidity(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.add(toMint)\n        );\n\n        return toMint;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token.\n     * @param self Swap struct to read from and write to\n     * @param tokenAmount the amount of the lp tokens to burn\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @return amount chosen token that user received\n     */\n    function removeLiquidityOneToken(\n        EvmoSwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount\n    ) external returns (uint256) {\n        LPToken lpToken = self.lpToken;\n        uint256 totalSupply = lpToken.totalSupply();\n        uint256 numTokens = self.pooledTokens.length;\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 dyFee;\n        uint256 dy;\n\n        (dy, dyFee) = calculateWithdrawOneToken(\n            self,\n            msg.sender,\n            tokenAmount,\n            tokenIndex,\n            _updateBaseVirtualPrice(metaSwapStorage),\n            totalSupply\n        );\n\n        require(dy >= minAmount, \"dy < minAmount\");\n\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(\n            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\n        );\n        lpToken.burnFrom(msg.sender, tokenAmount);\n        self.pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\n\n        emit RemoveLiquidityOne(\n            msg.sender,\n            tokenAmount,\n            totalSupply,\n            tokenIndex,\n            dy\n        );\n\n        return dy;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances.\n     *\n     * @param self Swap struct to read from and write to\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @return actual amount of LP tokens burned in the withdrawal\n     */\n    function removeLiquidityImbalance(\n        EvmoSwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        ManageLiquidityInfo memory v =\n            ManageLiquidityInfo(\n                0,\n                0,\n                0,\n                self.lpToken,\n                0,\n                getAPrecise(self),\n                _updateBaseVirtualPrice(metaSwapStorage),\n                self.tokenPrecisionMultipliers,\n                self.balances\n            );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        require(\n            amounts.length == v.newBalances.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        uint256 feePerToken = _feePerToken(self);\n\n        uint256[] memory fees = new uint256[](v.newBalances.length);\n        {\n            uint256[] memory balances1 = new uint256[](v.newBalances.length);\n\n            v.d0 = getD(\n                _xp(\n                    v.newBalances,\n                    v.tokenPrecisionMultipliers,\n                    v.baseVirtualPrice\n                ),\n                v.preciseA\n            );\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                balances1[i] = v.newBalances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.newBalances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n        }\n\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(\n            FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, msg.sender))\n        );\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < v.newBalances.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }\n}"
    },
    "contracts/stable/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title MathUtils library\n * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating\n * differences between two uint256.\n */\nlibrary MathUtils {\n    /**\n     * @notice Compares a and b and returns true if the difference between a and b\n     *         is less than 1 or equal to each other.\n     * @param a uint256 to compare with\n     * @param b uint256 to compare with\n     * @return True if the difference between a and b is less than 1 or equal,\n     *         otherwise return false\n     */\n    function within1(uint256 a, uint256 b) external pure returns (bool) {\n        return (_difference(a, b) <= 1);\n    }\n\n    /**\n     * @notice Calculates absolute difference between a and b\n     * @param a uint256 to compare with\n     * @param b uint256 to compare with\n     * @return Difference between a and b\n     */\n    function difference(uint256 a, uint256 b) external pure returns (uint256) {\n        return _difference(a, b);\n    }\n\n    /**\n     * @notice Calculates absolute difference between a and b\n     * @param a uint256 to compare with\n     * @param b uint256 to compare with\n     * @return Difference between a and b\n     */\n    function _difference(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return a - b;\n        }\n        return b - a;\n    }\n}\n"
    },
    "contracts/stable/EvmoSwapUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./LPToken.sol\";\nimport \"./MathUtils.sol\";\n\n/**\n * @title SwapUtils library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary EvmoSwapUtils {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using MathUtils for uint256;\n\n    /*** EVENTS ***/\n\n    event TokenSwap(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n    event NewDepositFee(uint256 newDepositFee);\n    event RampA(\n        uint256 oldA,\n        uint256 newA,\n        uint256 initialTime,\n        uint256 futureTime\n    );\n    event StopRampA(uint256 currentA, uint256 time);\n\n    struct Swap {\n        // variables around the ramp management of A,\n        // the amplification coefficient * n * (n - 1)\n        // see https://www.curve.fi/stableswap-paper.pdf for details\n        uint256 initialA;\n        uint256 futureA;\n        uint256 initialATime;\n        uint256 futureATime;\n        // fee calculation\n        uint256 swapFee;\n        uint256 adminFee;\n        uint256 defaultDepositFee;\n        uint256 defaultWithdrawFee;\n        address devaddr;\n        LPToken lpToken;\n        // contract references for all tokens being pooled\n        IERC20[] pooledTokens;\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n        uint256[] tokenPrecisionMultipliers;\n        // the pool balance of each token, in the token's precision\n        // the contract's actual token balance might differ\n        uint256[] balances;\n        mapping(address => uint256) depositTimestamp;\n        mapping(address => uint256) withdrawFeeMultiplier;\n    }\n\n    // Struct storing variables used in calculations in the\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n    struct CalculateWithdrawOneTokenDYInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 newY;\n        uint256 feePerToken;\n        uint256 preciseA;\n    }\n\n    // Struct storing variables used in calculation in addLiquidity function\n    // to avoid stack too deep error\n    struct AddLiquidityInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 d2;\n        uint256 preciseA;\n    }\n\n    // Struct storing variables used in calculation in removeLiquidityImbalance function\n    // to avoid stack too deep error\n    struct RemoveLiquidityImbalanceInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 d2;\n        uint256 preciseA;\n    }\n\n    // the precision all pools tokens will be converted to\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\n\n    // the denominator used to calculate admin and LP fees. For example, an\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n\n    // Max swap fee is 1% or 100bps of each swap\n    uint256 public constant MAX_SWAP_FEE = 10**8;\n\n    // Max adminFee is 100% of the swapFee\n    // adminFee does not add additional fee on top of swapFee\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n    // users but only on the earnings of LPs\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\n\n    // Max withdrawFee is 1% of the value withdrawn\n    // Fee will be redistributed to the LPs in the pool, rewarding\n    // long term providers.\n    uint256 public constant MAX_WITHDRAW_FEE = 10**8;\n\n    // Max depositFee is 1% of the value deposited\n    uint256 public constant MAX_DEPOSIT_FEE = 10**8;\n    \n    // Constant value used as max loop limit\n    uint256 private constant MAX_LOOP_LIMIT = 256;\n\n    // Constant values used in ramping A calculations\n    uint256 public constant A_PRECISION = 100;\n    uint256 public constant MAX_A = 10**6;\n    uint256 private constant MAX_A_CHANGE = 2;\n    uint256 private constant MIN_RAMP_TIME = 14 days;\n\n    /*** VIEW & PURE FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter\n     */\n    function getA(Swap storage self) external view returns (uint256) {\n        return _getA(self);\n    }\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter\n     */\n    function _getA(Swap storage self) internal view returns (uint256) {\n        return _getAPrecise(self).div(A_PRECISION);\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise(Swap storage self) external view returns (uint256) {\n        return _getAPrecise(self);\n    }\n\n    /**\n     * @notice Calculates and returns A based on the ramp settings\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\n        uint256 t1 = self.futureATime; // time when ramp is finished\n        uint256 a1 = self.futureA; // final A value when ramp is finished\n\n        if (block.timestamp < t1) {\n            uint256 t0 = self.initialATime; // time when ramp is started\n            uint256 a0 = self.initialA; // initial A value when ramp is started\n            if (a1 > a0) {\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\n                return\n                    a0.add(\n                        a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\n                    );\n            } else {\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\n                return\n                    a0.sub(\n                        a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\n                    );\n            }\n        } else {\n            return a1;\n        }\n    }\n\n    /**\n     * @notice Retrieves the timestamp of last deposit made by the given address\n     * @param self Swap struct to read from\n     * @return timestamp of last deposit\n     */\n    function getDepositTimestamp(Swap storage self, address user)\n        external\n        view\n        returns (uint256)\n    {\n        return self.depositTimestamp[user];\n    }\n\n    /**\n     * @notice Calculate the dy, the amount of selected token that user receives and\n     * the fee of withdrawing in one token\n     * @param account the address that is withdrawing\n     * @param tokenAmount the amount to withdraw in the pool's precision\n     * @param tokenIndex which token will be withdrawn\n     * @param self Swap struct to read from\n     * @return the amount of token user will receive and the associated swap fee\n     */\n    function calculateWithdrawOneToken(\n        Swap storage self,\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) public view returns (uint256, uint256) {\n        uint256 dy;\n        uint256 newY;\n\n        (dy, newY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount);\n\n        // dy_0 (without fees)\n        // dy, dy_0 - dy\n\n        uint256 dySwapFee =\n            _xp(self)[tokenIndex]\n                .sub(newY)\n                .div(self.tokenPrecisionMultipliers[tokenIndex])\n                .sub(dy);\n\n        dy = dy\n            .mul(\n            FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, account))\n        )\n            .div(FEE_DENOMINATOR);\n\n        return (dy, dySwapFee);\n    }\n\n    /**\n     * @notice Calculate the dy of withdrawing in one token\n     * @param self Swap struct to read from\n     * @param tokenIndex which token will be withdrawn\n     * @param tokenAmount the amount to withdraw in the pools precision\n     * @return the d and the new y after withdrawing one token\n     */\n    function calculateWithdrawOneTokenDY(\n        Swap storage self,\n        uint8 tokenIndex,\n        uint256 tokenAmount\n    ) internal view returns (uint256, uint256) {\n        require(\n            tokenIndex < self.pooledTokens.length,\n            \"Token index out of range\"\n        );\n\n        // Get the current D, then solve the stableswap invariant\n        // y_i for D - tokenAmount\n        uint256[] memory xp = _xp(self);\n        CalculateWithdrawOneTokenDYInfo memory v =\n            CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n        v.preciseA = _getAPrecise(self);\n        v.d0 = getD(xp, v.preciseA);\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(self.lpToken.totalSupply()));\n\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\n\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\n\n        uint256[] memory xpReduced = new uint256[](xp.length);\n\n        v.feePerToken = _feePerToken(self);\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 xpi = xp[i];\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\n            xpReduced[i] = xpi.sub(\n                (\n                    (i == tokenIndex)\n                        ? xpi.mul(v.d1).div(v.d0).sub(v.newY)\n                        : xpi.sub(xpi.mul(v.d1).div(v.d0))\n                )\n                    .mul(v.feePerToken)\n                    .div(FEE_DENOMINATOR)\n            );\n        }\n\n        uint256 dy =\n            xpReduced[tokenIndex].sub(\n                getYD(v.preciseA, tokenIndex, xpReduced, v.d1)\n            );\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\n\n        return (dy, v.newY);\n    }\n\n    /**\n     * @notice Calculate the price of a token in the pool with given\n     * precision-adjusted balances and a particular D.\n     *\n     * @dev This is accomplished via solving the invariant iteratively.\n     * See the StableSwap paper and Curve.fi implementation for further details.\n     *\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n     * x_1**2 + b*x_1 = c\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\n     *\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n     * @param tokenIndex Index of token we are calculating for.\n     * @param xp a precision-adjusted set of pool balances. Array should be\n     * the same cardinality as the pool.\n     * @param d the stableswap invariant\n     * @return the price of the token, in the same precision as in xp\n     */\n    function getYD(\n        uint256 a,\n        uint8 tokenIndex,\n        uint256[] memory xp,\n        uint256 d\n    ) internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = a.mul(numTokens);\n\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i != tokenIndex) {\n                s = s.add(xp[i]);\n                c = c.mul(d).div(xp[i].mul(numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // c = c * D * D * D * ... overflow!\n            }\n        }\n        c = c.mul(d).mul(A_PRECISION).div(nA.mul(numTokens));\n\n        uint256 b = s.add(d.mul(A_PRECISION).div(nA));\n        uint256 yPrev;\n        uint256 y = d;\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n     * as the pool.\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n     * See the StableSwap paper for details\n     * @return the invariant, at the precision of the pool\n     */\n    function getD(uint256[] memory xp, uint256 a)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 numTokens = xp.length;\n        uint256 s;\n        for (uint256 i = 0; i < numTokens; i++) {\n            s = s.add(xp[i]);\n        }\n        if (s == 0) {\n            return 0;\n        }\n\n        uint256 prevD;\n        uint256 d = s;\n        uint256 nA = a.mul(numTokens);\n\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            uint256 dP = d;\n            for (uint256 j = 0; j < numTokens; j++) {\n                dP = dP.mul(d).div(xp[j].mul(numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // dP = dP * D * D * D * ... overflow!\n            }\n            prevD = d;\n            d = nA.mul(s).div(A_PRECISION).add(dP.mul(numTokens)).mul(d).div(\n                nA.sub(A_PRECISION).mul(d).div(A_PRECISION).add(\n                    numTokens.add(1).mul(dP)\n                )\n            );\n            if (d.within1(prevD)) {\n                return d;\n            }\n        }\n\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n        // function which does not rely on D.\n        revert(\"D does not converge\");\n    }\n\n    /**\n     * @notice Get D, the StableSwap invariant, based on self Swap struct\n     * @param self Swap struct to read from\n     * @return The invariant, at the precision of the pool\n     */\n    function getD(Swap storage self) internal view returns (uint256) {\n        return getD(_xp(self), _getAPrecise(self));\n    }\n\n    /**\n     * @notice Given a set of balances and precision multipliers, return the\n     * precision-adjusted balances.\n     *\n     * @param balances an array of token balances, in their native precisions.\n     * These should generally correspond with pooled tokens.\n     *\n     * @param precisionMultipliers an array of multipliers, corresponding to\n     * the amounts in the balances array. When multiplied together they\n     * should yield amounts at the pool's precision.\n     *\n     * @return an array of amounts \"scaled\" to the pool's precision\n     */\n    function _xp(\n        uint256[] memory balances,\n        uint256[] memory precisionMultipliers\n    ) internal pure returns (uint256[] memory) {\n        uint256 numTokens = balances.length;\n        require(\n            numTokens == precisionMultipliers.length,\n            \"Balances must match multipliers\"\n        );\n        uint256[] memory xp = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; i++) {\n            xp[i] = balances[i].mul(precisionMultipliers[i]);\n        }\n        return xp;\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @param self Swap struct to read from\n     * @param balances array of balances to scale\n     * @return balances array \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(Swap storage self, uint256[] memory balances)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        return _xp(balances, self.tokenPrecisionMultipliers);\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @param self Swap struct to read from\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @param self Swap struct to read from\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice(Swap storage self)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 d = getD(_xp(self), _getAPrecise(self));\n        uint256 supply = self.lpToken.totalSupply();\n        if (supply > 0) {\n            return\n                d.mul(10**uint256(ERC20(self.lpToken).decimals())).div(supply);\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Calculate the new balances of the tokens given the indexes of the token\n     * that is swapped from (FROM) and the token that is swapped to (TO).\n     * This function is used as a helper function to calculate how much TO token\n     * the user should receive on swap.\n     *\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom index of FROM token\n     * @param tokenIndexTo index of TO token\n     * @param x the new total amount of FROM token\n     * @param xp balances of the tokens in the pool\n     * @return the amount of TO token that should remain in the pool\n     */\n    function getY(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 x,\n        uint256[] memory xp\n    ) internal view returns (uint256) {\n        uint256 numTokens = self.pooledTokens.length;\n        require(\n            tokenIndexFrom != tokenIndexTo,\n            \"Can't compare token to itself\"\n        );\n        require(\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\n            \"Tokens must be in pool\"\n        );\n\n        uint256 a = _getAPrecise(self);\n        uint256 d = getD(xp, a);\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = numTokens.mul(a);\n\n        uint256 _x;\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i == tokenIndexFrom) {\n                _x = x;\n            } else if (i != tokenIndexTo) {\n                _x = xp[i];\n            } else {\n                continue;\n            }\n            s = s.add(_x);\n            c = c.mul(d).div(_x.mul(numTokens));\n            // If we were to protect the division loss we would have to keep the denominator separate\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\n            // c = c * D * D * D * ... overflow!\n        }\n        c = c.mul(d).mul(A_PRECISION).div(nA.mul(numTokens));\n        uint256 b = s.add(d.mul(A_PRECISION).div(nA));\n        uint256 yPrev;\n        uint256 y = d;\n\n        // iterative approximation\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Externally calculates a swap between two tokens.\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     */\n    function calculateSwap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 dy) {\n        (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx);\n    }\n\n    /**\n     * @notice Internally calculates a swap between two tokens.\n     *\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\n     * using the token contracts.\n     *\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     * @return dyFee the associated fee\n     */\n    function _calculateSwap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) internal view returns (uint256 dy, uint256 dyFee) {\n        uint256[] memory xp = _xp(self);\n        require(\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\n            \"Token index out of range\"\n        );\n        uint256 x =\n            dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]).add(\n                xp[tokenIndexFrom]\n            );\n        uint256 y = getY(self, tokenIndexFrom, tokenIndexTo, x, xp);\n        dy = xp[tokenIndexTo].sub(y).sub(1);\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n        dy = dy.sub(dyFee).div(self.tokenPrecisionMultipliers[tokenIndexTo]);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of\n     * LP tokens\n     *\n     * @param account the address that is removing liquidity. required for withdraw fee calculation\n     * @param amount the amount of LP tokens that would to be burned on\n     * withdrawal\n     * @return array of amounts of tokens user will receive\n     */\n    function calculateRemoveLiquidity(\n        Swap storage self,\n        address account,\n        uint256 amount\n    ) external view returns (uint256[] memory) {\n        return _calculateRemoveLiquidity(self, account, amount);\n    }\n\n    function _calculateRemoveLiquidity(\n        Swap storage self,\n        address account,\n        uint256 amount\n    ) internal view returns (uint256[] memory) {\n        uint256 totalSupply = self.lpToken.totalSupply();\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\n\n        uint256 feeAdjustedAmount =\n            amount\n                .mul(\n                FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, account))\n            )\n                .div(FEE_DENOMINATOR);\n\n        uint256[] memory amounts = new uint256[](self.pooledTokens.length);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            amounts[i] = self.balances[i].mul(feeAdjustedAmount).div(\n                totalSupply\n            );\n        }\n        return amounts;\n    }\n\n    /**\n     * @notice Calculate the fee that is applied when the given user withdraws.\n     * Withdraw fee decays linearly over 4 weeks.\n     * @param user address you want to calculate withdraw fee of\n     * @return current withdraw fee of the user\n     */\n    function calculateCurrentWithdrawFee(Swap storage self, address user)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 endTime = self.depositTimestamp[user].add(4 weeks);\n        if (endTime > block.timestamp) {\n            uint256 timeLeftover = endTime.sub(block.timestamp);\n            return\n                self\n                    .defaultWithdrawFee\n                    .mul(self.withdrawFeeMultiplier[user])\n                    .mul(timeLeftover)\n                    .div(4 weeks)\n                    .div(FEE_DENOMINATOR);\n        }\n        return 0;\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param self Swap struct to read from\n     * @param account address of the account depositing or withdrawing tokens\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return if deposit was true, total amount of lp token that will be minted and if\n     * deposit was false, total amount of lp token that will be burned\n     */\n    function calculateTokenAmount(\n        Swap storage self,\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256) {\n        uint256 numTokens = self.pooledTokens.length;\n        uint256 a = _getAPrecise(self);\n        uint256 d0 = getD(_xp(self, self.balances), a);\n        uint256[] memory balances1 = self.balances;\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (deposit) {\n                balances1[i] = balances1[i].add(amounts[i]);\n            } else {\n                balances1[i] = balances1[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n        }\n        uint256 d1 = getD(_xp(self, balances1), a);\n        uint256 totalSupply = self.lpToken.totalSupply();\n\n        if (deposit) {\n            return d1.sub(d0).mul(totalSupply).div(d0);\n        } else {\n            return\n                d0.sub(d1).mul(totalSupply).div(d0).mul(FEE_DENOMINATOR).div(\n                    FEE_DENOMINATOR.sub(\n                        calculateCurrentWithdrawFee(self, account)\n                    )\n                );\n        }\n    }\n\n    /**\n     * @notice return accumulated amount of admin fees of the token with given index\n     * @param self Swap struct to read from\n     * @param index Index of the pooled token\n     * @return admin balance in the token's precision\n     */\n    function getAdminBalance(Swap storage self, uint256 index)\n        external\n        view\n        returns (uint256)\n    {\n        require(index < self.pooledTokens.length, \"Token index out of range\");\n        return\n            self.pooledTokens[index].balanceOf(address(this)).sub(\n                self.balances[index]\n            );\n    }\n\n    /**\n     * @notice internal helper function to calculate fee per token multiplier used in\n     * swap fee calculations\n     * @param self Swap struct to read from\n     */\n    function _feePerToken(Swap storage self) internal view returns (uint256) {\n        return\n            self.swapFee.mul(self.pooledTokens.length).div(\n                self.pooledTokens.length.sub(1).mul(4)\n            );\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice swap two tokens in the pool\n     * @param self Swap struct to read from and write to\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @return amount of token user received on swap\n     */\n    function swap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy\n    ) external returns (uint256) {\n        require(\n            dx <= self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender),\n            \"Cannot swap more than you own\"\n        );\n\n        // Transfer tokens first to see if a fee was charged on transfer\n        uint256 beforeBalance =\n            self.pooledTokens[tokenIndexFrom].balanceOf(address(this));\n        self.pooledTokens[tokenIndexFrom].safeTransferFrom(\n            msg.sender,\n            address(this),\n            dx\n        );\n\n        // Use the actual transferred amount for AMM math\n        uint256 transferredDx =\n            self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(\n                beforeBalance\n            );\n\n        (uint256 dy, uint256 dyFee) =\n            _calculateSwap(self, tokenIndexFrom, tokenIndexTo, transferredDx);\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n        uint256 dyAdminFee =\n            dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n                self.tokenPrecisionMultipliers[tokenIndexTo]\n            );\n\n        self.balances[tokenIndexFrom] = self.balances[tokenIndexFrom].add(\n            transferredDx\n        );\n        self.balances[tokenIndexTo] = self.balances[tokenIndexTo].sub(dy).sub(\n            dyAdminFee\n        );\n\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n        emit TokenSwap(\n            msg.sender,\n            transferredDx,\n            dy,\n            tokenIndexFrom,\n            tokenIndexTo\n        );\n\n        return dy;\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param self Swap struct to read from and write to\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @return amount of LP token user received\n     */\n    function addLiquidity(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 minToMint\n    ) external returns (uint256) {\n        require(\n            amounts.length == self.pooledTokens.length,\n            \"Amounts must match pooled tokens\"\n        );\n\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\n\n        // current state\n        AddLiquidityInfo memory v = AddLiquidityInfo(0, 0, 0, 0);\n\n        if (self.lpToken.totalSupply() != 0) {\n            v.d0 = getD(self);\n        }\n        uint256[] memory newBalances = self.balances;\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            require(\n                self.lpToken.totalSupply() != 0 || amounts[i] > 0,\n                \"Must supply all tokens in pool\"\n            );\n\n            // Transfer tokens first to see if a fee was charged on transfer\n            if (amounts[i] != 0) {\n                uint256 beforeBalance =\n                    self.pooledTokens[i].balanceOf(address(this));\n                self.pooledTokens[i].safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amounts[i]\n                );\n\n                // Update the amounts[] with actual transfer amount\n                amounts[i] = self.pooledTokens[i].balanceOf(address(this)).sub(\n                    beforeBalance\n                );\n            }\n\n            newBalances[i] = self.balances[i].add(amounts[i]);\n        }\n\n        // invariant after change\n        v.preciseA = _getAPrecise(self);\n        v.d1 = getD(_xp(self, newBalances), v.preciseA);\n        require(v.d1 > v.d0, \"D should increase\");\n\n        // updated to reflect fees and calculate the user's LP tokens\n        v.d2 = v.d1;\n        if (self.lpToken.totalSupply() != 0) {\n            uint256 feePerToken = _feePerToken(self);\n            for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n                fees[i] = feePerToken\n                    .mul(idealBalance.difference(newBalances[i]))\n                    .div(FEE_DENOMINATOR);\n                self.balances[i] = newBalances[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                newBalances[i] = newBalances[i].sub(fees[i]);\n            }\n            v.d2 = getD(_xp(self, newBalances), v.preciseA);\n        } else {\n            // the initial depositor doesn't pay fees\n            self.balances = newBalances;\n        }\n\n        uint256 toMint;\n        uint256 toMintFee;\n        uint256 toMintUser;\n        if (self.lpToken.totalSupply() == 0) {\n            toMint = v.d1;\n        } else {\n            toMint = v.d2.sub(v.d0).mul(self.lpToken.totalSupply()).div(v.d0);\n        }\n\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\n        // if deposit fee is none, mint full amount\n        if (self.defaultDepositFee == 0) {\n            self.lpToken.mint(msg.sender, toMint);\n        } else {\n            // mint the user's LP tokens minus the deposit fee\n            toMintFee = toMint.mul(self.defaultDepositFee).div(FEE_DENOMINATOR);\n            toMintUser = toMint.sub(toMintFee);\n            self.lpToken.mint(self.devaddr, toMintFee);\n            self.lpToken.mint(msg.sender, toMintUser);\n        }\n       \n        emit AddLiquidity(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            self.lpToken.totalSupply()\n        );\n\n        return toMint;\n    }\n\n    /**\n     * @notice Update the withdraw fee for `user`. If the user is currently\n     * not providing liquidity in the pool, sets to default value. If not, recalculate\n     * the starting withdraw fee based on the last deposit's time & amount relative\n     * to the new deposit.\n     *\n     * @param self Swap struct to read from and write to\n     * @param user address of the user depositing tokens\n     * @param toMint amount of pool tokens to be minted\n     */\n    function updateUserWithdrawFee(\n        Swap storage self,\n        address user,\n        uint256 toMint\n    ) external {\n        _updateUserWithdrawFee(self, user, toMint);\n    }\n\n    function _updateUserWithdrawFee(\n        Swap storage self,\n        address user,\n        uint256 toMint\n    ) internal {\n        // If token is transferred to address 0 (or burned), don't update the fee.\n        if (user == address(0)) {\n            return;\n        }\n        if (self.defaultWithdrawFee == 0) {\n            // If current fee is set to 0%, set multiplier to FEE_DENOMINATOR\n            self.withdrawFeeMultiplier[user] = FEE_DENOMINATOR;\n        } else {\n            // Otherwise, calculate appropriate discount based on last deposit amount\n            uint256 currentFee = calculateCurrentWithdrawFee(self, user);\n            uint256 currentBalance = self.lpToken.balanceOf(user);\n\n            // ((currentBalance * currentFee) + (toMint * defaultWithdrawFee)) * FEE_DENOMINATOR /\n            // ((toMint + currentBalance) * defaultWithdrawFee)\n            self.withdrawFeeMultiplier[user] = currentBalance\n                .mul(currentFee)\n                .add(toMint.mul(self.defaultWithdrawFee))\n                .mul(FEE_DENOMINATOR)\n                .div(toMint.add(currentBalance).mul(self.defaultWithdrawFee));\n        }\n        self.depositTimestamp[user] = block.timestamp;\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param self Swap struct to read from and write to\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     * acceptable for this burn. Useful as a front-running mitigation\n     * @return amounts of tokens the user received\n     */\n    function removeLiquidity(\n        Swap storage self,\n        uint256 amount,\n        uint256[] calldata minAmounts\n    ) external returns (uint256[] memory) {\n        require(amount <= self.lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(\n            minAmounts.length == self.pooledTokens.length,\n            \"minAmounts must match poolTokens\"\n        );\n\n        uint256[] memory amounts =\n            _calculateRemoveLiquidity(self, msg.sender, amount);\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\n            self.balances[i] = self.balances[i].sub(amounts[i]);\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        self.lpToken.burnFrom(msg.sender, amount);\n\n        emit RemoveLiquidity(msg.sender, amounts, self.lpToken.totalSupply());\n\n        return amounts;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token.\n     * @param self Swap struct to read from and write to\n     * @param tokenAmount the amount of the lp tokens to burn\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @return amount chosen token that user received\n     */\n    function removeLiquidityOneToken(\n        Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount\n    ) external returns (uint256) {\n        uint256 totalSupply = self.lpToken.totalSupply();\n        uint256 numTokens = self.pooledTokens.length;\n        require(\n            tokenAmount <= self.lpToken.balanceOf(msg.sender),\n            \">LP.balanceOf\"\n        );\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 dyFee;\n        uint256 dy;\n\n        (dy, dyFee) = calculateWithdrawOneToken(\n            self,\n            msg.sender,\n            tokenAmount,\n            tokenIndex\n        );\n\n        require(dy >= minAmount, \"dy < minAmount\");\n\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(\n            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\n        );\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\n        self.pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\n\n        emit RemoveLiquidityOne(\n            msg.sender,\n            tokenAmount,\n            totalSupply,\n            tokenIndex,\n            dy\n        );\n\n        return dy;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances.\n     *\n     * @param self Swap struct to read from and write to\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @return actual amount of LP tokens burned in the withdrawal\n     */\n    function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        require(\n            amounts.length == self.pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(\n            maxBurnAmount <= self.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        RemoveLiquidityImbalanceInfo memory v =\n            RemoveLiquidityImbalanceInfo(0, 0, 0, 0);\n\n        uint256 tokenSupply = self.lpToken.totalSupply();\n        uint256 feePerToken = _feePerToken(self);\n\n        uint256[] memory balances1 = self.balances;\n\n        v.preciseA = _getAPrecise(self);\n        v.d0 = getD(_xp(self), v.preciseA);\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            balances1[i] = balances1[i].sub(\n                amounts[i],\n                \"Cannot withdraw more than available\"\n            );\n        }\n        v.d1 = getD(_xp(self, balances1), v.preciseA);\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n            uint256 difference = idealBalance.difference(balances1[i]);\n            fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n            self.balances[i] = balances1[i].sub(\n                fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n            );\n            balances1[i] = balances1[i].sub(fees[i]);\n        }\n\n        v.d2 = getD(_xp(self, balances1), v.preciseA);\n\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(tokenSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(\n            FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, msg.sender))\n        );\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            tokenSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }\n\n    /**\n     * @notice withdraw all admin fees to a given address\n     * @param self Swap struct to withdraw fees from\n     * @param to Address to send the fees to\n     */\n    function withdrawAdminFees(Swap storage self, address to) external {\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            IERC20 token = self.pooledTokens[i];\n            uint256 balance =\n                token.balanceOf(address(this)).sub(self.balances[i]);\n            if (balance != 0) {\n                token.safeTransfer(to, balance);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets the admin fee\n     * @dev adminFee cannot be higher than 100% of the swap fee\n     * @param self Swap struct to update\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\n        self.adminFee = newAdminFee;\n\n        emit NewAdminFee(newAdminFee);\n    }\n\n    /**\n     * @notice update the swap fee\n     * @dev fee cannot be higher than 1% of each swap\n     * @param self Swap struct to update\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\n        self.swapFee = newSwapFee;\n\n        emit NewSwapFee(newSwapFee);\n    }\n\n    /**\n     * @notice update the default withdraw fee. This also affects deposits made in the past as well.\n     * @param self Swap struct to update\n     * @param newWithdrawFee new withdraw fee to be applied\n     */\n    function setDefaultWithdrawFee(Swap storage self, uint256 newWithdrawFee)\n        external\n    {\n        require(newWithdrawFee <= MAX_WITHDRAW_FEE, \"Fee is too high\");\n        self.defaultWithdrawFee = newWithdrawFee;\n\n        emit NewWithdrawFee(newWithdrawFee);\n    }\n\n    /**\n     * @notice update the default deposit fee. \n     * @param self Swap struct to update\n     * @param newDepositFee new deposit fee to be applied\n     */\n    function setDefaultDepositFee(Swap storage self, uint256 newDepositFee)\n        external\n    {\n        require(newDepositFee <= MAX_DEPOSIT_FEE, \"Fee is too high\");\n        self.defaultDepositFee = newDepositFee;\n\n        emit NewDepositFee(newDepositFee);\n    }\n\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param self Swap struct to update\n     * @param futureA_ the new A to ramp towards\n     * @param futureTime_ timestamp when the new A should be reached\n     */\n    function rampA(\n        Swap storage self,\n        uint256 futureA_,\n        uint256 futureTime_\n    ) external {\n        require(\n            block.timestamp >= self.initialATime.add(1 days),\n            \"Wait 1 day before starting ramp\"\n        );\n        require(\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\n            \"Insufficient ramp time\"\n        );\n        require(\n            futureA_ > 0 && futureA_ < MAX_A,\n            \"futureA_ must be > 0 and < MAX_A\"\n        );\n\n        uint256 initialAPrecise = _getAPrecise(self);\n        uint256 futureAPrecise = futureA_.mul(A_PRECISION);\n\n        if (futureAPrecise < initialAPrecise) {\n            require(\n                futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise,\n                \"futureA_ is too small\"\n            );\n        } else {\n            require(\n                futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE),\n                \"futureA_ is too large\"\n            );\n        }\n\n        self.initialA = initialAPrecise;\n        self.futureA = futureAPrecise;\n        self.initialATime = block.timestamp;\n        self.futureATime = futureTime_;\n\n        emit RampA(\n            initialAPrecise,\n            futureAPrecise,\n            block.timestamp,\n            futureTime_\n        );\n    }\n\n    /**\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\n     * cannot be called for another 24 hours\n     * @param self Swap struct to update\n     */\n    function stopRampA(Swap storage self) external {\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\n        uint256 currentA = _getAPrecise(self);\n\n        self.initialA = currentA;\n        self.futureA = currentA;\n        self.initialATime = block.timestamp;\n        self.futureATime = block.timestamp;\n\n        emit StopRampA(currentA, block.timestamp);\n    }\n\n    function setDevAddress(Swap storage self, address _devaddr) public {\n        require(msg.sender == self.devaddr, \"dev: wut?\");\n        self.devaddr = _devaddr;\n    }\n}"
    },
    "contracts/stable/LPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./ISwap.sol\";\n\n/**\n * @title Liquidity Provider Token\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\n * It is used to represent user's shares when providing liquidity to swap contracts.\n */\ncontract LPToken is ERC20Burnable, Ownable {\n    using SafeMath for uint256;\n\n    // Address of the swap contract that owns this LP token. When a user adds liquidity to the swap contract,\n    // they receive a proportionate amount of this LPToken.\n    ISwap public immutable swap;\n\n    /**\n     * @notice Deploys LPToken contract with given name, symbol, and decimals\n     * @dev the caller of this constructor will become the owner of this contract\n     * @param name_ name of this token\n     * @param symbol_ symbol of this token\n     * @param decimals_ number of decimals this token will be based on\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) public ERC20(name_, symbol_) {\n        _setupDecimals(decimals_);\n        swap = ISwap(_msgSender());\n    }\n\n    /**\n     * @notice Mints the given amount of LPToken to the recipient.\n     * @dev only owner can call this mint function\n     * @param recipient address of account to receive the tokens\n     * @param amount amount of tokens to mint\n     */\n    function mint(\n        address recipient,\n        uint256 amount\n    ) external onlyOwner {\n        require(amount != 0, \"amount == 0\");\n        _mint(recipient, amount);\n    }\n\n    /**\n     * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\n     * minting and burning. This ensures that swap.updateUserWithdrawFees are called everytime.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20) {\n        super._beforeTokenTransfer(from, to, amount);\n        swap.updateUserWithdrawFee(to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/tools/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 supply\n    ) public ERC20(name, symbol) {\n        _setupDecimals(6);\n        _mint(msg.sender, supply);\n    }\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n}"
    },
    "contracts/staking/EvmoSwapBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./EMOToken.sol\";\n\n// EvmoSwapBar with Governance.\ncontract EvmoSwapBar is ERC20('EvmoSwapBar Token', 'xEMO'), Ownable {\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\n    function mint(address _to, uint256 _amount) public onlyOwner {\n        _mint(_to, _amount);\n        _moveDelegates(address(0), _delegates[_to], _amount);\n    }\n\n    function burn(address _from ,uint256 _amount) public onlyOwner {\n        _burn(_from, _amount);\n        _moveDelegates(_delegates[_from], address(0), _amount);\n    }\n\n    // The EMO TOKEN!\n    EMOToken public emo;\n\n\n    constructor(\n        EMOToken _emo\n    ) public {\n        emo = _emo;\n    }\n\n    // Safe emo transfer function, just in case if rounding error causes pool to not have enough EMOs.\n    function safeEmoTransfer(address _to, uint256 _amount) public onlyOwner {\n        uint256 emoBal = emo.balanceOf(address(this));\n        if (_amount > emoBal) {\n            emo.transfer(_to, emoBal);\n        } else {\n            emo.transfer(_to, _amount);\n        }\n    }\n\n    // Copied and modified from YAM code:\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\n    // Which is copied and modified from COMPOUND:\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n    /// @dev A record of each accounts delegate\n    mapping (address => address) internal _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator)\n    external\n    view\n    returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n    external\n    {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"xEMO::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"xEMO::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"xEMO::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n    external\n    view\n    returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n    external\n    view\n    returns (uint256)\n    {\n        require(blockNumber < block.number, \"xEMO::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n    internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying EMOs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n    internal\n    {\n        uint32 blockNumber = safe32(block.number, \"xEMO::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}\n"
    },
    "contracts/stable/OwnerPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/**\n * @title OwnerPausable\n * @notice An ownable contract allows the owner to pause and unpause the\n * contract without a delay.\n * @dev Only methods using the provided modifiers will be paused.\n */\ncontract OwnerPausable is Ownable, Pausable {\n    /**\n     * @notice Pause the contract. Revert if already paused.\n     */\n    function pause() external onlyOwner {\n        Pausable._pause();\n    }\n\n    /**\n     * @notice Unpause the contract. Revert if already unpaused.\n     */\n    function unpause() external onlyOwner {\n        Pausable._unpause();\n    }\n}\n"
    },
    "contracts/stable/EvmoSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./OwnerPausable.sol\";\nimport \"./EvmoSwapUtils.sol\";\nimport \"./MathUtils.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\ncontract EvmoSwap is OwnerPausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using MathUtils for uint256;\n    using EvmoSwapUtils for EvmoSwapUtils.Swap;\n\n    // Struct storing data responsible for automatic market maker functionalities. In order to\n    // access this data, this contract uses EvmoSwapUtils library. For more details, see EvmoSwapUtils.sol\n    EvmoSwapUtils.Swap public swapStorage;\n\n    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\n    // getTokenIndex function also relies on this mapping to retrieve token index.\n    mapping(address => uint8) private tokenIndexes;\n\n    /*** EVENTS ***/\n\n    // events replicated from EvmoSwapUtils to make the ABI easier for dumb\n    // clients\n    event TokenSwap(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewDepositFee(uint256 newDepositFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n    event RampA(\n        uint256 oldA,\n        uint256 newA,\n        uint256 initialTime,\n        uint256 futureTime\n    );\n    event StopRampA(uint256 currentA, uint256 time);\n\n    /**\n     * @notice Deploys this Swap contract with given parameters as default\n     * values. This will also deploy a LPToken that represents users\n     * LP position. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint new tokens.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept\n     * @param decimals the decimals to use for each pooled token,\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param lpTokenName the long-form name of the token to be deployed\n     * @param lpTokenSymbol the short symbol for the token to be deployed\n     * @param _a the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     * @param _depositFee default depositFee to be initialized with\n     * @param _withdrawFee default withdrawFee to be initialized with\n     * @param _devaddr default _devaddr to be initialized with\n     */\n    constructor(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _depositFee,\n        uint256 _withdrawFee,\n        address _devaddr\n    ) public OwnerPausable() ReentrancyGuard() {\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                        _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= EvmoSwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n                10 **\n                    uint256(EvmoSwapUtils.POOL_PRECISION_DECIMALS).sub(\n                        uint256(decimals[i])\n                    );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _depositFee, _withdrawFee\n        require(_a < EvmoSwapUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < EvmoSwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < EvmoSwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n        require(\n            _withdrawFee < EvmoSwapUtils.MAX_WITHDRAW_FEE,\n            \"_withdrawFee exceeds maximum\"\n        );\n        require(\n            _depositFee < EvmoSwapUtils.MAX_DEPOSIT_FEE,\n            \"_depositFee exceeds maximum\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = new LPToken(\n            lpTokenName,\n            lpTokenSymbol,\n            EvmoSwapUtils.POOL_PRECISION_DECIMALS\n        );\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(EvmoSwapUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(EvmoSwapUtils.A_PRECISION);\n        swapStorage.initialATime = 0;\n        swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n        swapStorage.defaultDepositFee = _depositFee;\n        swapStorage.defaultWithdrawFee = _withdrawFee;\n        swapStorage.devaddr = _devaddr;\n\n    }\n\n    /*** MODIFIERS ***/\n\n    /**\n     * @notice Modifier to check deadline against current timestamp\n     * @param deadline latest timestamp to accept this transaction\n     */\n    modifier deadlineCheck(uint256 deadline) {\n        require(block.timestamp <= deadline, \"Deadline not met\");\n        _;\n    }\n\n    /*** VIEW FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function getA() external view returns (uint256) {\n        return swapStorage.getA();\n    }\n\n    /**\n     * @notice Return A in its raw precision form\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise() external view returns (uint256) {\n        return swapStorage.getAPrecise();\n    }\n\n    /**\n     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n     * @param index the index of the token\n     * @return address of the token at given index\n     */\n    function getToken(uint8 index) public view returns (IERC20) {\n        require(index < swapStorage.pooledTokens.length, \"Out of range\");\n        return swapStorage.pooledTokens[index];\n    }\n\n    /**\n     * @notice Return the index of the given token address. Reverts if no matching\n     * token is found.\n     * @param tokenAddress address of the token\n     * @return the index of the given token address\n     */\n    function getTokenIndex(address tokenAddress) external view returns (uint8) {\n        uint8 index = tokenIndexes[tokenAddress];\n        require(\n            address(getToken(index)) == tokenAddress,\n            \"Token does not exist\"\n        );\n        return index;\n    }\n\n    /**\n     * @notice Return timestamp of last deposit of given address\n     * @return timestamp of the last deposit made by the given address\n     */\n    function getDepositTimestamp(address user) external view returns (uint256) {\n        return swapStorage.getDepositTimestamp(user);\n    }\n\n    /**\n     * @notice Return current balance of the pooled token at given index\n     * @param index the index of the token\n     * @return current balance of the pooled token at given index with token's native precision\n     */\n    function getTokenBalance(uint8 index) external view returns (uint256) {\n        require(index < swapStorage.pooledTokens.length, \"Index out of range\");\n        return swapStorage.balances[index];\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice() external virtual view returns (uint256) {\n        return swapStorage.getVirtualPrice();\n    }\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external virtual view returns (uint256) {\n        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param account address that is depositing or withdrawing tokens\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external virtual view returns (uint256) {\n        return swapStorage.calculateTokenAmount(account, amounts, deposit);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of LP tokens\n     * @param account the address that is withdrawing tokens\n     * @param amount the amount of LP tokens that would be burned on withdrawal\n     * @return array of token balances that the user will receive\n     */\n    function calculateRemoveLiquidity(address account, uint256 amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return swapStorage.calculateRemoveLiquidity(account, amount);\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param account the address that is withdrawing tokens\n     * @param tokenAmount the amount of LP token to burn\n     * @param tokenIndex index of which token will be withdrawn\n     * @return availableTokenAmount calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external virtual view returns (uint256 availableTokenAmount) {\n        (availableTokenAmount, ) = swapStorage.calculateWithdrawOneToken(\n            account,\n            tokenAmount,\n            tokenIndex\n        );\n    }\n\n    /**\n     * @notice Calculate the fee that is applied when the given user withdraws. The withdraw fee\n     * decays linearly over period of 4 weeks. For example, depositing and withdrawing right away\n     * will charge you the full amount of withdraw fee. But withdrawing after 4 weeks will charge you\n     * no additional fees.\n     * @dev returned value should be divided by FEE_DENOMINATOR to convert to correct decimals\n     * @param user address you want to calculate withdraw fee of\n     * @return current withdraw fee of the user\n     */\n    function calculateCurrentWithdrawFee(address user)\n        external\n        view\n        returns (uint256)\n    {\n        return swapStorage.calculateCurrentWithdrawFee(user);\n    }\n\n    /**\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\n     * @param index Index of the pooled token\n     * @return admin's token balance in the token's precision\n     */\n    function getAdminBalance(uint256 index) external view returns (uint256) {\n        return swapStorage.getAdminBalance(index);\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice Swap two tokens using this pool\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    )\n        external\n        virtual\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n    }\n\n    /**\n     * @notice Add liquidity to the pool with given amounts\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP token user minted and received\n     */\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    )\n        external\n        virtual\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return swapStorage.addLiquidity(amounts, minToMint);\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     *        acceptable for this burn. Useful as a front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * @return amounts of tokens user received\n     */\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external nonReentrant deadlineCheck(deadline) returns (uint256[] memory) {\n        return swapStorage.removeLiquidity(amount, minAmounts);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param tokenAmount the amount of the token you want to receive\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of chosen token user received\n     */\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    )\n        external\n        virtual\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            swapStorage.removeLiquidityOneToken(\n                tokenAmount,\n                tokenIndex,\n                minAmount\n            );\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP tokens burned\n     */\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    )\n        external\n        virtual\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\n    }\n\n    /*** ADMIN FUNCTIONS ***/\n\n    /**\n     * @notice Updates the user withdraw fee. This function can only be called by\n     * the pool token. Should be used to update the withdraw fee on transfer of pool tokens.\n     * Transferring your pool token will reset the 4 weeks period. If the recipient is already\n     * holding some pool tokens, the withdraw fee will be discounted in respective amounts.\n     * @param recipient address of the recipient of pool token\n     * @param transferAmount amount of pool token to transfer\n     */\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\n        external\n    {\n        require(\n            msg.sender == address(swapStorage.lpToken),\n            \"Only callable by pool token\"\n        );\n        swapStorage.updateUserWithdrawFee(recipient, transferAmount);\n    }\n\n    /**\n     * @notice Withdraw all admin fees to the contract owner\n     */\n    function withdrawAdminFees() external onlyOwner {\n        swapStorage.withdrawAdminFees(owner());\n    }\n\n    /**\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(uint256 newAdminFee) external onlyOwner {\n        swapStorage.setAdminFee(newAdminFee);\n    }\n\n    /**\n     * @notice Update the swap fee to be applied on swaps\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(uint256 newSwapFee) external onlyOwner {\n        swapStorage.setSwapFee(newSwapFee);\n    }\n\n        /**\n     * @notice Update the deposit fee. \n     * @param newDepositFee new deposit fee to be applied on future deposits\n     */\n    function setDefaultDepositFee(uint256 newDepositFee) external onlyOwner {\n        swapStorage.setDefaultDepositFee(newDepositFee);\n    }\n\n    /**\n     * @notice Update the withdraw fee. This fee decays linearly over 4 weeks since\n     * user's last deposit.\n     * @param newWithdrawFee new withdraw fee to be applied on future deposits\n     */\n    function setDefaultWithdrawFee(uint256 newWithdrawFee) external onlyOwner {\n        swapStorage.setDefaultWithdrawFee(newWithdrawFee);\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param futureA the new A to ramp towards\n     * @param futureTime timestamp when the new A should be reached\n     */\n    function rampA(uint256 futureA, uint256 futureTime) external onlyOwner {\n        swapStorage.rampA(futureA, futureTime);\n    }\n\n    /**\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n     */\n    function stopRampA() external onlyOwner {\n        swapStorage.stopRampA();\n    }\n\n        // Update dev address by the previous dev.\n    function setDevAddress(address _devaddr) external onlyOwner {\n        swapStorage.setDevAddress(_devaddr);\n    }\n}"
    },
    "contracts/stable/MetaSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./ISwap.sol\";\nimport \"./EvmoSwap.sol\";\nimport \"./MetaSwapUtils.sol\";\n\n/**\n * @title MetaSwap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * MetaSwap is a modified version of Swap that allows Swap's LP token to be utilized in pooling with other tokens.\n *\n * @dev Most of the logic is stored as a library `EvmoSwapUtils` for the sake of reducing contract's\n * deployment size.\n */\ncontract MetaSwap is EvmoSwap {\n    using MetaSwapUtils for EvmoSwapUtils.Swap;\n\n    MetaSwapUtils.MetaSwap public metaSwapStorage;\n\n    uint256 constant MAX_UINT256 = 2**256 - 1;\n\n    /*** EVENTS ***/\n\n    // events replicated from EvmoSwapUtils to make the ABI easier for dumb\n    // clients\n    event TokenSwapUnderlying(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n\n    /**\n     * @notice Initializes this Swap contract with the given parameters.\n     * This will also deploy the LPToken that represents users\n     * LP position. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint new tokens.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept\n     * @param decimals the decimals to use for each pooled token,\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param lpTokenName the long-form name of the token to be deployed\n     * @param lpTokenSymbol the short symbol for the token to be deployed\n     * @param _a the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     * @param _depositFee default depositFee to be initialized with\n     * @param _withdrawFee default withdrawFee to be initialized with\n     * @param _devaddr default _devaddr to be initialized with\n     */\n    constructor (\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _depositFee,\n        uint256 _withdrawFee,\n        address _devaddr,\n        ISwap baseSwap\n    ) EvmoSwap(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            _depositFee,\n            _withdrawFee,\n            _devaddr\n        ) public {\n\n        // MetaSwap initializer\n        metaSwapStorage.baseSwap = baseSwap;\n        metaSwapStorage.baseVirtualPrice = baseSwap.getVirtualPrice();\n        metaSwapStorage.baseCacheLastUpdated = block.timestamp;\n        for (uint8 i; i < 32; i++) {\n            try baseSwap.getToken(i) returns (IERC20 token) {\n                token.approve(address(baseSwap), MAX_UINT256);\n                metaSwapStorage.baseTokens.push(token);\n            } catch {\n                break;\n            }\n        }\n        _pooledTokens[_pooledTokens.length - 1].approve(\n            address(baseSwap),\n            MAX_UINT256\n        );\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice()\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return swapStorage.getVirtualPrice(metaSwapStorage);\n    }\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view virtual override returns (uint256) {\n        return\n            swapStorage.calculateSwap(\n                metaSwapStorage,\n                tokenIndexFrom,\n                tokenIndexTo,\n                dx\n            );\n    }\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap. For this function,\n     * the token indices are flattened out so that underlying tokens are represented.\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwapUnderlying(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view virtual returns (uint256) {\n        return\n            swapStorage.calculateSwapUnderlying(\n                metaSwapStorage,\n                tokenIndexFrom,\n                tokenIndexTo,\n                dx\n            );\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param account address that is depositing or withdrawing tokens\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external virtual view override returns (uint256) {\n        return\n            swapStorage.calculateTokenAmount(\n                metaSwapStorage,\n                account,\n                amounts,\n                deposit\n            );\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param account the address that is withdrawing tokens\n     * @param tokenAmount the amount of LP token to burn\n     * @param tokenIndex index of which token will be withdrawn\n     * @return availableTokenAmount calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view virtual override returns (uint256) {\n        return\n            swapStorage.calculateWithdrawOneToken(\n                metaSwapStorage,\n                account,\n                tokenAmount,\n                tokenIndex\n            );\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice Swap two tokens using this pool\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            swapStorage.swap(\n                metaSwapStorage,\n                tokenIndexFrom,\n                tokenIndexTo,\n                dx,\n                minDy\n            );\n    }\n\n    /**\n     * @notice Swap two tokens using this pool and the base pool.\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function swapUnderlying(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    )\n        external\n        virtual\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            swapStorage.swapUnderlying(\n                metaSwapStorage,\n                tokenIndexFrom,\n                tokenIndexTo,\n                dx,\n                minDy\n            );\n    }\n\n    /**\n     * @notice Add liquidity to the pool with the given amounts of tokens\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP token user minted and received\n     */\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return swapStorage.addLiquidity(metaSwapStorage, amounts, minToMint);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param tokenAmount the amount of the token you want to receive\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of chosen token user received\n     */\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            swapStorage.removeLiquidityOneToken(\n                metaSwapStorage,\n                tokenAmount,\n                tokenIndex,\n                minAmount\n            );\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP tokens burned\n     */\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            swapStorage.removeLiquidityImbalance(\n                metaSwapStorage,\n                amounts,\n                maxBurnAmount\n            );\n    }\n}"
    },
    "contracts/stable/AmplificationUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./EvmoSwapUtils.sol\";\n\npragma solidity 0.6.12;\n\nlibrary AmplificationUtils {\n    using SafeMath for uint256;\n\n    event RampA(\n        uint256 oldA,\n        uint256 newA,\n        uint256 initialTime,\n        uint256 futureTime\n    );\n    event StopRampA(uint256 currentA, uint256 time);\n\n    // Constant values used in ramping A calculations\n    uint256 public constant A_PRECISION = 100;\n    uint256 public constant MAX_A = 10**6;\n    uint256 private constant MAX_A_CHANGE = 2;\n    uint256 private constant MIN_RAMP_TIME = 14 days;\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param self Swap struct to update\n     * @param futureA_ the new A to ramp towards\n     * @param futureTime_ timestamp when the new A should be reached\n     */\n    function rampA(\n        EvmoSwapUtils.Swap storage self,\n        uint256 initialAPrecise,\n        uint256 futureA_,\n        uint256 futureTime_\n    ) external {\n        require(\n            block.timestamp >= self.initialATime.add(1 days),\n            \"Wait 1 day before starting ramp\"\n        );\n        require(\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\n            \"Insufficient ramp time\"\n        );\n        require(\n            futureA_ > 0 && futureA_ < MAX_A,\n            \"futureA_ must be > 0 and < MAX_A\"\n        );\n\n        uint256 futureAPrecise = futureA_.mul(A_PRECISION);\n\n        if (futureAPrecise < initialAPrecise) {\n            require(\n                futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise,\n                \"futureA_ is too small\"\n            );\n        } else {\n            require(\n                futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE),\n                \"futureA_ is too large\"\n            );\n        }\n\n        self.initialA = initialAPrecise;\n        self.futureA = futureAPrecise;\n        self.initialATime = block.timestamp;\n        self.futureATime = futureTime_;\n\n        emit RampA(\n            initialAPrecise,\n            futureAPrecise,\n            block.timestamp,\n            futureTime_\n        );\n    }\n\n    /**\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\n     * cannot be called for another 24 hours\n     * @param self Swap struct to update\n     */\n    function stopRampA(EvmoSwapUtils.Swap storage self, uint256 currentA) external {\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\n\n        self.initialA = currentA;\n        self.futureA = currentA;\n        self.initialATime = block.timestamp;\n        self.futureATime = block.timestamp;\n\n        emit StopRampA(currentA, block.timestamp);\n    }\n}"
    },
    "contracts/stable/ILPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./ISwap.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ILPToken is IERC20 {\n    function swap() external view returns (ISwap);\n}\n"
    },
    "contracts/interfaces/IEvmoSwapIFO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/** @title IEvmoSwapIFO.\n * @notice It is an interface for EvmoSwapIFO.sol\n */\ninterface IEvmoSwapIFO {\n    /**\n    * @notice It returns the offering token\n    */\n    function offeringToken() external view returns (IERC20);\n\n    /**\n     * @notice It allows users to deposit LP tokens to pool\n     * @param _amount: the number of LP token used (18 decimals)\n     * @param _pid: poolId\n     */\n    function depositPool(uint256 _amount, uint8 _pid) external;\n\n    /**\n     * @notice It allows users to harvest from pool\n     * @param _pid: poolId\n     */\n    function harvestPool(uint8 _pid) external;\n\n    /**\n     * @notice It allows the admin to withdraw funds\n     * @param _lpAmount: the number of LP token to withdraw (18 decimals)\n     * @param _offerAmount: the number of offering amount to withdraw\n     * @dev This function is only callable by admin.\n     */\n    function finalWithdraw(uint256[] memory _lpAmount, uint256 _offerAmount) external;\n\n    /**\n     * @notice It sets parameters for pool\n     * @param _offeringAmountPool: offering amount (in tokens)\n     * @param _raisingAmountPool: raising amount (in LP tokens)\n     * @param _limitPerUserInRaisingToken: limit per user (in LP tokens)\n     * @param _initialReleasePercentage: initial release percentage (if 10000, it is 100%)\n     * @param _vestingEndTime: vesting end time\n     * @param _hasTax: if the pool has a tax\n     * @param _pid: poolId\n     * @dev This function is only callable by admin.\n     */\n    function setPool(\n        address _raisingToken,\n        uint256 _offeringAmountPool,\n        uint256 _raisingAmountPool,\n        uint256 _limitPerUserInRaisingToken,\n        uint256 _initialReleasePercentage,\n        uint256 _burnPercentage,\n        uint256 _vestingEndTime,\n        bool _hasTax,\n        uint8 _pid\n    ) external;\n\n    /**\n     * @notice It updates campaignId for the IFO.\n     * @param _campaignId: the campaignId for the IFO\n     * @dev This function is only callable by admin.\n     */\n    function updateCampaignId(\n        uint256 _campaignId\n    ) external;\n\n    /**\n     * @notice It returns the pool information\n     * @param _pid: poolId\n     */\n    function viewPoolInformation(uint256 _pid)\n    external\n    view\n    returns (\n        IERC20,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        bool,\n        uint256,\n        uint256\n    );\n\n    /**\n     * @notice It returns the tax overflow rate calculated for a pool\n     * @dev 100,000 means 0.1(10%)/ 1 means 0.000001(0.0001%)/ 1,000,000 means 1(100%)\n     * @param _pid: poolId\n     * @return It returns the tax percentage\n     */\n    function viewPoolTaxRateOverflow(uint256 _pid) external view returns (uint256);\n\n    /**\n     * @notice External view function to see user information\n     * @param _user: user address\n     * @param _pids[]: array of pids\n     */\n    function viewUserInfo(address _user, uint8[] calldata _pids)\n    external\n    view\n    returns (uint256[] memory, uint256[] memory, uint256[] memory, bool[] memory, bool[] memory);\n\n    /**\n     * @notice External view function to see user allocations for both pools\n     * @param _user: user address\n     * @param _pids[]: array of pids\n     */\n    function viewUserAllocationPools(address _user, uint8[] calldata _pids) external view returns (uint256[] memory);\n\n    /**\n     * @notice External view function to see user offering and refunding amounts for both pools\n     * @param _user: user address\n     * @param _pids: array of pids\n     */\n    function viewUserOfferingAndRefundingAmountsForPools(address _user, uint8[] calldata _pids)\n    external\n    view\n    returns (uint256[3][] memory);\n}\n"
    },
    "contracts/ifo/IFOInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../interfaces/IEvmoSwapIFO.sol\";\nimport \"../interfaces/IVotingEscrow.sol\";\n\n/**\n * @title IFOInitializable\n */\n\ncontract IFOInitializable is IEvmoSwapIFO, ReentrancyGuard, Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // The offering token\n    IERC20 public override offeringToken;\n\n    // Max time interval (for sanity checks)\n    uint256 public MAX_BUFFER_TIME_INTERVAL;\n\n    // Number of pools\n    uint8 public constant NUMBER_POOLS = 2;\n\n    // MULTIPLIER\n    uint8 public constant VE_RATE = 10;\n\n    uint256 constant public PERCENTAGE_FACTOR = 10000;\n\n    // The address of the smart chef factory\n    address public immutable IFO_FACTORY;\n\n    // VotingEscrow contract\n    address public votingEscrowAddress;\n\n    // Whether it is initialized\n    bool public isInitialized;\n\n    // Allow claim\n    bool public allowClaim;\n\n    // The block timestamp when IFO starts\n    uint256 public startTime;\n\n    // The block timestamp when IFO ends\n    uint256 public endTime;\n\n    // The campaignId for the IFO\n    uint256 public campaignId;\n\n    // Total tokens distributed across the pools\n    uint256 public totalTokensOffered;\n\n    // Total amount of raising token withdrew\n    uint256[NUMBER_POOLS] public totalWithdrawRaisingAmount;\n\n    // The address burns raisingToken\n    address public burnAddress;\n\n    // The address receive remaining raisingToken after burning, like PostIFOLauncher\n    address public receiverAddress;\n\n    // Total amount of tax(raising token) withdrew\n    uint256[NUMBER_POOLS] public totalWithdrawTaxAmount;\n\n    // The address receive tax\n    address public taxCollector;\n\n    // Array of PoolCharacteristics of size NUMBER_POOLS\n    PoolCharacteristics[NUMBER_POOLS] private _poolInformation;\n\n    // It maps the address to pool id to UserInfo\n    mapping(address => mapping(uint8 => UserInfo)) private _userInfo;\n\n    // Struct that contains each pool characteristics\n    struct PoolCharacteristics {\n        IERC20 raisingToken; // The raising token\n        uint256 raisingAmountPool; // amount of tokens raised for the pool (in raising tokens)\n        uint256 offeringAmountPool; // amount of tokens offered for the pool (in offeringTokens)\n        uint256 limitPerUserInRaisingToken; // limit of tokens per user (if 0, it is ignored)\n        uint256 initialReleasePercentage; // percentage releases immediately when ifo ends(if 10000, it is 100%)\n        uint256 burnPercentage; // The percentag of raisingToken to burn,multiply by PERCENTAGE_FACTOR (100 means 0.01)\n        uint256 vestingEndTime; // block timestamp when 100% of tokens have been released\n        bool hasTax; // tax on the overflow (if any, it works with _calculateTaxOverflow)\n        uint256 totalAmountPool; // total amount pool deposited (in raising tokens)\n        uint256 sumTaxesOverflow; // total taxes collected (starts at 0, increases with each harvest if overflow)\n    }\n\n    // Struct that contains each user information for both pools\n    struct UserInfo {\n        uint256 amountPool; // How many tokens the user has provided for pool\n        uint256 offeringTokensClaimed; // How many tokens has been claimed by user\n        uint256 lastTimeHarvested; // The time when user claimed recently\n        bool hasHarvestedInitial; // If initial is claimed\n        bool refunded; // If the user is refunded\n    }\n\n    // Admin withdraw events\n    event AdminWithdraw(uint256[] amountRaisingTokens, uint256 amountOfferingToken);\n\n    // Admin recovers token\n    event AdminTokenRecovery(address tokenAddress, uint256 amountTokens);\n\n    // Deposit event\n    event Deposit(address indexed user, uint8 indexed pid, uint256 amount);\n\n    // Harvest event\n    event Harvest(address indexed user, uint8 indexed pid, uint256 offeringAmount, uint256 excessAmount);\n\n    // Event for new start & end timestamp\n    event NewStartAndEndTimes(uint256 startTime, uint256 endTime);\n\n    // Event with campaignId for IFO\n    event CampaignIdSet(uint256 campaignId);\n\n    // Event when parameters are set for one of the pools\n    event PoolParametersSet(uint8 pid, uint256 offeringAmountPool, uint256 raisingAmountPool);\n\n    // Modifier to prevent contracts to participate\n    modifier notContract() {\n        require(!_isContract(msg.sender), \"contract not allowed\");\n        require(msg.sender == tx.origin, \"proxy contract not allowed\");\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     */\n    constructor() public {\n        IFO_FACTORY = msg.sender;\n    }\n\n    /**\n     * @notice It initializes the contract\n     * @dev It can only be called once.\n     * @param _offeringToken: the token that is offered for the IFO\n     * @param _startTime: the start timestamp for the IFO\n     * @param _endTime: the end timestamp for the IFO\n     * @param _adminAddress: the admin address for handling tokens\n     * @param _votingEscrowAddress: the address of the VotingEscrow\n     */\n    function initialize(\n        address _offeringToken,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _maxBufferTimeInterval,\n        address _adminAddress,\n        address _votingEscrowAddress,\n        address _burnAddress,\n        address _receiverAddress\n    ) public {\n        require(!isInitialized, \"Operations: Already initialized\");\n        require(msg.sender == IFO_FACTORY, \"Operations: Not factory\");\n        require(_receiverAddress != address(0), \"Operations: Zero address\");\n\n        // Make this contract initialized\n        isInitialized = true;\n\n        // init not allow claim\n        allowClaim = false; \n\n        offeringToken = IERC20(_offeringToken);\n        votingEscrowAddress = _votingEscrowAddress;\n        startTime = _startTime;\n        endTime = _endTime;\n        MAX_BUFFER_TIME_INTERVAL = _maxBufferTimeInterval;\n\n        burnAddress = _burnAddress;\n        receiverAddress = _receiverAddress;\n\n        // Transfer ownership to admin\n        transferOwnership(_adminAddress);\n    }\n\n    /**\n     * @notice It allows users to deposit raising tokens to pool\n     * @param _amount: the number of raising token used (18 decimals)\n     * @param _pid: pool id\n     */\n    function depositPool(uint256 _amount, uint8 _pid) external override nonReentrant notContract {\n        // Checks whether the pool id is valid\n        require(_pid < NUMBER_POOLS, \"Deposit: Non valid pool id\");\n\n        // Checks that pool was set\n        require(\n            _poolInformation[_pid].offeringAmountPool > 0 && _poolInformation[_pid].raisingAmountPool > 0,\n            \"Deposit: Pool not set\"\n        );\n\n        // Checks whether the block timestamp is not too early\n        require(block.timestamp > startTime, \"Deposit: Too early\");\n\n        // Checks whether the block timestamp is not too late\n        require(block.timestamp < endTime, \"Deposit: Too late\");\n\n        // Checks that the amount deposited is not inferior to 0\n        require(_amount > 0, \"Deposit: Amount must be > 0\");\n\n        // Verify tokens were deposited properly\n        require(offeringToken.balanceOf(address(this)) >= totalTokensOffered, \"Deposit: Tokens not deposited properly\");\n\n        // amount of veEmo from votingEscrow, only for base sale\n        if (votingEscrowAddress != address(0) && _pid == 0) {\n            uint256 veDecimal = IVotingEscrow(votingEscrowAddress).decimals();\n            uint256 raisingDecimal = IVotingEscrow(address(_poolInformation[_pid].raisingToken)).decimals();\n            require(veDecimal >= raisingDecimal, \"Wrong decimal\");\n\n            uint256 ifoCredit = IVotingEscrow(votingEscrowAddress).balanceOfT(msg.sender, startTime) * VE_RATE;\n            require(_userInfo[msg.sender][_pid].amountPool.add(_amount).mul(10 ** (veDecimal - raisingDecimal)) <= ifoCredit, \"Not enough veEmo\");\n        }\n\n        // Transfers funds to this contract\n        _poolInformation[_pid].raisingToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n\n        // Update the user status\n        _userInfo[msg.sender][_pid].amountPool = _userInfo[msg.sender][_pid].amountPool.add(_amount);\n\n        // Check if the pool has a limit per user\n        if (_poolInformation[_pid].limitPerUserInRaisingToken > 0) {\n            // Checks whether the limit has been reached\n            require(\n                _userInfo[msg.sender][_pid].amountPool <= _poolInformation[_pid].limitPerUserInRaisingToken,\n                \"Deposit: New amount above user limit\"\n            );\n        }\n\n        // Updates the totalAmount for pool\n        _poolInformation[_pid].totalAmountPool = _poolInformation[_pid].totalAmountPool.add(_amount);\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    /**\n     * @notice It allows users to harvest from pool\n     * @param _pid: pool id\n     */\n    function harvestPool(uint8 _pid) external override nonReentrant notContract {\n        // Checks whether it is allow to harvest\n        require(allowClaim, \"Harvest: not allow claim\");\n\n        // Checks whether pool id is valid\n        require(_pid < NUMBER_POOLS, \"Harvest: Non valid pool id\");\n\n        UserInfo storage currentUserInfo = _userInfo[msg.sender][_pid];\n\n        // Checks whether the user has participated\n        require(currentUserInfo.amountPool > 0, \"Harvest: Did not participate\");\n\n        // Checks whether the user has already harvested in the same block\n        require(currentUserInfo.lastTimeHarvested < block.timestamp, \"Harvest: Already harvest in the same block\");\n\n        // Initialize the variables for offering, refunding user amounts, and tax amount\n        (\n        uint256 raisingTokenRefund,\n        uint256 userTaxOverflow,\n        uint256 offeringTokenTotalHarvest,,,\n        ) = userTokenStatus(msg.sender, _pid);\n\n        // Updates the harvest time\n        currentUserInfo.lastTimeHarvested = block.timestamp;\n        currentUserInfo.hasHarvestedInitial = true;\n\n        // Settle refund\n        if (!currentUserInfo.refunded) {\n            currentUserInfo.refunded = true;\n            if (raisingTokenRefund > 0) {\n                _poolInformation[_pid].raisingToken.safeTransfer(msg.sender, raisingTokenRefund);\n            }\n            // Increment the sumTaxesOverflow\n            if (userTaxOverflow > 0) {\n                _poolInformation[_pid].sumTaxesOverflow = _poolInformation[_pid].sumTaxesOverflow.add(userTaxOverflow);\n            }\n        }\n\n        // Final check to verify the user has not gotten more tokens that originally allocated\n        (uint256 offeringTokenAmount,,) = _calculateOfferingAndRefundingAmountsPool(msg.sender, _pid);\n        uint256 offeringAllocationLeft = offeringTokenAmount - currentUserInfo.offeringTokensClaimed;\n        uint256 allocatedTokens = offeringAllocationLeft >= offeringTokenTotalHarvest ? offeringTokenTotalHarvest : offeringAllocationLeft;\n        if (allocatedTokens > 0) {\n            currentUserInfo.offeringTokensClaimed += allocatedTokens;\n            offeringToken.safeTransfer(msg.sender, allocatedTokens);\n        }\n\n        emit Harvest(msg.sender, _pid, allocatedTokens, raisingTokenRefund);\n    }\n\n    /**\n     * @notice It allows the admin to withdraw funds\n     * @param _raisingAmounts: the number array of raising token to withdraw\n     * @param _offeringAmount: the number of offering amount to withdraw\n     * @dev This function is only callable by admin.\n     */\n    function finalWithdraw(uint256[] memory _raisingAmounts, uint256 _offeringAmount) external override onlyOwner {\n        require(_raisingAmounts.length == NUMBER_POOLS, \"Operations: Wrong length\");\n      \n        for (uint i; i < NUMBER_POOLS; i++) {\n            if(_raisingAmounts[i] > 0) {\n                PoolCharacteristics memory poolInfo = _poolInformation[i];\n                require(_raisingAmounts[i] <= poolInfo.raisingToken.balanceOf(address(this)), \"Operations: Not enough raising tokens\");\n\n                totalWithdrawRaisingAmount[i] = totalWithdrawRaisingAmount[i].add(_raisingAmounts[i]);\n                require(totalWithdrawRaisingAmount[i] <= poolInfo.raisingAmountPool, \"Operations: Maximum allowance exceeds\");\n\n                uint burnAmount = 0;\n                if (poolInfo.burnPercentage != 0) {\n                    burnAmount = _raisingAmounts[i].mul(poolInfo.burnPercentage).div(PERCENTAGE_FACTOR);\n                    poolInfo.raisingToken.safeTransfer(burnAddress, burnAmount);\n                }\n                poolInfo.raisingToken.safeTransfer(receiverAddress, _raisingAmounts[i].sub(burnAmount));\n            }\n        }\n\n        if (_offeringAmount > 0) {\n            require(_offeringAmount <= offeringToken.balanceOf(address(this)), \"Operations: Not enough offering tokens\");\n            offeringToken.safeTransfer(address(msg.sender), _offeringAmount);\n        }\n\n        emit AdminWithdraw(_raisingAmounts, _offeringAmount);\n    }\n\n    /**\n     * @notice It allows the admin or collector to withdraw tax\n     * @dev This function is only callable by admin or collector.\n     */\n    function taxWithdraw() external {\n        require(taxCollector != address(0), \"Operations: Wrong tax collector\");\n        require(owner() == msg.sender || taxCollector == msg.sender, \"Operations: Permission denied\");\n\n        for (uint i; i < NUMBER_POOLS; i++) {\n            uint256 sumTaxesOverflow = _poolInformation[i].sumTaxesOverflow;\n            _poolInformation[i].raisingToken.safeTransfer(taxCollector, sumTaxesOverflow.sub(totalWithdrawTaxAmount[i]));\n            totalWithdrawTaxAmount[i] = sumTaxesOverflow;\n        }\n    }\n\n    /**\n     * @notice It allows the admin to recover wrong tokens sent to the contract\n     * @param _tokenAddress: the address of the token to withdraw (18 decimals)\n     * @param _tokenAmount: the number of token amount to withdraw\n     * @dev This function is only callable by admin.\n     */\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(offeringToken), \"Recover: Cannot be offering token\");\n        for (uint i; i < NUMBER_POOLS; i++) {\n            require(_tokenAddress != address(_poolInformation[i].raisingToken), \"Recover: Cannot be raising token\");\n        }\n\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\n\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\n    }\n\n    /**\n     * @notice It sets parameters for pool\n     * @param _raisingToken: the raising token used\n     * @param _offeringAmountPool: offering amount (in tokens)\n     * @param _raisingAmountPool: raising amount (in raising tokens)\n     * @param _limitPerUserInRaisingToken: limit per user (in raising tokens)\n     * @param _initialReleasePercentage: initial release percentage (if 10000, it is 100%)\n     * @param _vestingEndTime: vesting end time\n     * @param _hasTax: if the pool has a tax\n     * @param _pid: pool id\n     * @dev This function is only callable by admin.\n     */\n    function setPool(\n        address _raisingToken,\n        uint256 _offeringAmountPool,\n        uint256 _raisingAmountPool,\n        uint256 _limitPerUserInRaisingToken,\n        uint256 _initialReleasePercentage,\n        uint256 _burnPercentage,\n        uint256 _vestingEndTime,\n        bool _hasTax,\n        uint8 _pid\n    ) external override onlyOwner {\n        require(IERC20(_raisingToken).totalSupply() >= 0);\n        require(_raisingToken != address(offeringToken), \"Operations: Tokens must be be different\");\n        require(block.timestamp < startTime, \"Operations: IFO has started\");\n        require(_initialReleasePercentage <= PERCENTAGE_FACTOR, \"Operations: Wrong initial percentage\");\n        require(_burnPercentage <= PERCENTAGE_FACTOR, \"Operations: Wrong percentage\");\n        require(_vestingEndTime >= endTime, \"Operations: Vesting ends too early\");\n        require(_pid < NUMBER_POOLS, \"Operations: Pool does not exist\");\n\n        if (_vestingEndTime == endTime) {\n            require(_initialReleasePercentage == PERCENTAGE_FACTOR, \"Operations:Initial percentage should be equal to PERCENTAGE_FACTOR\");\n        }\n\n        _poolInformation[_pid].raisingToken = IERC20(_raisingToken);\n        _poolInformation[_pid].offeringAmountPool = _offeringAmountPool;\n        _poolInformation[_pid].raisingAmountPool = _raisingAmountPool;\n        _poolInformation[_pid].limitPerUserInRaisingToken = _limitPerUserInRaisingToken;\n        _poolInformation[_pid].initialReleasePercentage = _initialReleasePercentage;\n        _poolInformation[_pid].burnPercentage = _burnPercentage;\n        _poolInformation[_pid].vestingEndTime = _vestingEndTime;\n        _poolInformation[_pid].hasTax = _hasTax;\n\n        uint256 tokensDistributedAcrossPools;\n\n        for (uint8 i = 0; i < NUMBER_POOLS; i++) {\n            tokensDistributedAcrossPools = tokensDistributedAcrossPools.add(_poolInformation[i].offeringAmountPool);\n        }\n\n        // Update totalTokensOffered\n        totalTokensOffered = tokensDistributedAcrossPools;\n\n        emit PoolParametersSet(_pid, _offeringAmountPool, _raisingAmountPool);\n    }\n\n    /**\n     * @notice It updates campaignId for the IFO.\n     * @param _campaignId: the campaignId for the IFO\n     * @dev This function is only callable by admin.\n     */\n    function updateCampaignId(uint256 _campaignId) external override onlyOwner {\n        require(block.timestamp < endTime, \"Operations: IFO has ended\");\n        campaignId = _campaignId;\n\n        emit CampaignIdSet(campaignId);\n    }\n\n    /**\n     * @notice It allows the admin to update start and end timestamp\n     * @param _startTime: the new start timestamp\n     * @param _endTime: the new end timestamp\n     * @dev This function is only callable by admin.\n     */\n    function updateStartAndEndTimes(uint256 _startTime, uint256 _endTime) external onlyOwner {\n        require(_endTime < (block.timestamp + MAX_BUFFER_TIME_INTERVAL), \"Operations: EndTime too far\");\n        require(block.timestamp < startTime, \"Operations: IFO has started\");\n        require(_startTime < _endTime, \"Operations: New startTime must be less than new endTime\");\n        require(block.timestamp < _startTime, \"Operations: New startTime must be greater than current timestamp\");\n\n        startTime = _startTime;\n        endTime = _endTime;\n\n        emit NewStartAndEndTimes(_startTime, _endTime);\n    }\n\n    /**\n    * @notice It allows the admin to set\n    * @param _allow: claim status\n    * @dev This function is only callable by admin.\n    */\n    function setAllowClaim(bool _allow) external onlyOwner {\n        allowClaim = _allow;\n    }\n\n    /**\n    * @notice It allows the admin to update tax collector\n    * @param _taxCollector: the new tax collector\n    * @dev This function is only callable by admin.\n    */\n    function setTaxCollector(address _taxCollector) external onlyOwner {\n        taxCollector = _taxCollector;\n    }\n\n    /**\n     * @notice It returns the pool information\n     * @param _pid: poolId\n     * @return raisingAmountPool: amount of raising tokens raised (in raising tokens)\n     * @return offeringAmountPool: amount of tokens offered for the pool (in offeringTokens)\n     * @return limitPerUserInRaisingToken: limit of tokens per user (if 0, it is ignored)\n     * @return hasTax: tax on the overflow (if any, it works with _calculateTaxOverflow)\n     * @return totalAmountPool: total amount pool deposited (in raising tokens)\n     * @return sumTaxesOverflow: total taxes collected (starts at 0, increases with each harvest if overflow)\n     */\n    function viewPoolInformation(uint256 _pid)\n    external\n    view\n    override\n    returns (\n        IERC20,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        bool,\n        uint256,\n        uint256\n    )\n    {\n        PoolCharacteristics memory poolInfo = _poolInformation[_pid];\n        return (\n        poolInfo.raisingToken,\n        poolInfo.raisingAmountPool,\n        poolInfo.offeringAmountPool,\n        poolInfo.limitPerUserInRaisingToken,\n        poolInfo.initialReleasePercentage,\n        poolInfo.burnPercentage,\n        poolInfo.vestingEndTime,\n        poolInfo.hasTax,\n        poolInfo.totalAmountPool,\n        poolInfo.sumTaxesOverflow\n        );\n    }\n\n    /**\n     * @notice It returns the tax overflow rate calculated for a pool\n     * @dev 100,000,000,000 means 0.1 (10%) / 1 means 0.0000000000001 (0.0000001%) / 1,000,000,000,000 means 1 (100%)\n     * @param _pid: poolId\n     * @return It returns the tax percentage\n     */\n    function viewPoolTaxRateOverflow(uint256 _pid) external view override returns (uint256) {\n        if (!_poolInformation[_pid].hasTax) {\n            return 0;\n        } else {\n            return\n            _calculateTaxOverflow(_poolInformation[_pid].totalAmountPool, _poolInformation[_pid].raisingAmountPool);\n        }\n    }\n\n    /**\n     * @notice External view function to see user allocations for both pools\n     * @param _user: user address\n     * @param _pids[]: array of pids\n     * @return\n     */\n    function viewUserAllocationPools(address _user, uint8[] calldata _pids)\n    external\n    view\n    override\n    returns (uint256[] memory)\n    {\n        uint256[] memory allocationPools = new uint256[](_pids.length);\n        for (uint8 i = 0; i < _pids.length; i++) {\n            allocationPools[i] = _getUserAllocationPool(_user, _pids[i]);\n        }\n        return allocationPools;\n    }\n\n    /**\n     * @notice External view function to see user information\n     * @param _user: user address\n     * @param _pids[]: array of pids\n     */\n    function viewUserInfo(address _user, uint8[] calldata _pids)\n    external\n    view\n    override\n    returns (uint256[] memory, uint256[] memory, uint256[] memory, bool[] memory, bool[] memory)\n    {\n        uint256[] memory amountPools = new uint256[](_pids.length);\n        uint256[] memory offeringTokensClaimedPools = new uint256[](_pids.length);\n        uint256[] memory lastTimeHarvestedPools = new uint256[](_pids.length);\n        bool[] memory hasHarvestedInitialPools = new bool[](_pids.length);\n        bool[] memory refundedPools = new bool[](_pids.length);\n\n        for (uint8 i = 0; i < NUMBER_POOLS; i++) {\n            amountPools[i] = _userInfo[_user][i].amountPool;\n            offeringTokensClaimedPools[i] = _userInfo[_user][i].offeringTokensClaimed;\n            lastTimeHarvestedPools[i] = _userInfo[_user][i].lastTimeHarvested;\n            hasHarvestedInitialPools[i] = _userInfo[_user][i].hasHarvestedInitial;\n            refundedPools[i] = _userInfo[_user][i].refunded;\n        }\n        return (amountPools, offeringTokensClaimedPools, lastTimeHarvestedPools, hasHarvestedInitialPools, refundedPools);\n    }\n\n    /**\n     * @notice External view function to see user offering and refunding amounts for both pools\n     * @param _user: user address\n     * @param _pids: array of pids\n     */\n    function viewUserOfferingAndRefundingAmountsForPools(address _user, uint8[] calldata _pids)\n    external\n    view\n    override\n    returns (uint256[3][] memory)\n    {\n        uint256[3][] memory amountPools = new uint256[3][](_pids.length);\n\n        for (uint8 i = 0; i < _pids.length; i++) {\n            uint256 userOfferingAmountPool;\n            uint256 userRefundingAmountPool;\n            uint256 userTaxAmountPool;\n\n            if (_poolInformation[_pids[i]].raisingAmountPool > 0) {\n                (\n                userOfferingAmountPool,\n                userRefundingAmountPool,\n                userTaxAmountPool\n                ) = _calculateOfferingAndRefundingAmountsPool(_user, _pids[i]);\n            }\n\n            amountPools[i] = [userOfferingAmountPool, userRefundingAmountPool, userTaxAmountPool];\n        }\n        return amountPools;\n    }\n\n    /**\n    * @notice Get the amount of tokens a user is eligible to receive based on current state.\n    * @param _user: address of user to obtain token status\n    * @param _pid: pool id to obtain token status\n    * raisingTokenRefund:Amount of raising tokens available to refund\n    * userTaxOverflow: Amount of tax\n    * offeringTokenTotalHarvest: Total amount of offering tokens that can be harvested (initial + vested)\n    * offeringTokenInitialHarvest: Amount of initial harvest offering tokens that can be collected\n    * offeringTokenVestedHarvest: Amount offering tokens that can be harvested from the vesting portion of tokens\n    * offeringTokensVesting: Amount of offering tokens that are still vested\n    */\n    function userTokenStatus(address _user, uint8 _pid) public view returns (\n        uint256 raisingTokenRefund,\n        uint256 userTaxOverflow,\n        uint256 offeringTokenTotalHarvest,\n        uint256 offeringTokenInitialHarvest,\n        uint256 offeringTokenVestedHarvest,\n        uint256 offeringTokensVesting\n    ){\n        uint256 currentTime = block.timestamp;\n        if (currentTime < endTime) {\n            return (0, 0, 0, 0, 0, 0);\n        }\n\n        UserInfo memory currentUserInfo = _userInfo[_user][_pid];\n        PoolCharacteristics memory currentPoolInfo = _poolInformation[_pid];\n\n        // Initialize the variables for offering, refunding user amounts\n        (uint256 offeringTokenAmount, uint256 refundingTokenAmount, uint256 taxAmount) = _calculateOfferingAndRefundingAmountsPool(_user, _pid);\n        uint256 offeringTokenInitialAmount = offeringTokenAmount * currentPoolInfo.initialReleasePercentage / PERCENTAGE_FACTOR;\n        uint256 offeringTokenVestedAmount = offeringTokenAmount - offeringTokenInitialAmount;\n\n        // Setup refund amount\n        raisingTokenRefund = 0;\n        userTaxOverflow = 0;\n        if (!currentUserInfo.refunded) {\n            raisingTokenRefund = refundingTokenAmount;\n            userTaxOverflow = taxAmount;\n        }\n\n        // Setup initial harvest amount\n        offeringTokenInitialHarvest = 0;\n        if (!currentUserInfo.hasHarvestedInitial) {\n            offeringTokenInitialHarvest = offeringTokenInitialAmount;\n        }\n\n        // Setup harvestable vested token amount\n        offeringTokenVestedHarvest = 0;\n        offeringTokensVesting = 0;\n        // exclude initial\n        uint256 offeringTokenUnclaimed = offeringTokenAmount.sub(offeringTokenInitialHarvest).sub(currentUserInfo.offeringTokensClaimed);\n        if (currentTime >= currentPoolInfo.vestingEndTime) {\n            offeringTokenVestedHarvest = offeringTokenUnclaimed;\n        } else {\n            uint256 unlockEndTime = currentTime;\n            // endTime is the earliest time to harvest\n            uint256 lastHarvestTime = currentUserInfo.lastTimeHarvested < endTime ? endTime : currentUserInfo.lastTimeHarvested;\n            if (unlockEndTime > lastHarvestTime) {\n                uint256 totalVestingTime = currentPoolInfo.vestingEndTime - endTime;\n                uint256 unlockTime = unlockEndTime - lastHarvestTime;\n                offeringTokenVestedHarvest = (offeringTokenVestedAmount * unlockTime) / totalVestingTime;\n            }\n            offeringTokensVesting = offeringTokenUnclaimed.sub(offeringTokenVestedHarvest);\n        }\n        offeringTokenTotalHarvest = offeringTokenInitialHarvest + offeringTokenVestedHarvest;\n    }\n\n    /**\n     * @notice It calculates the tax overflow given the raisingAmountPool and the totalAmountPool.\n     * @dev 100,000,000,000 means 0.1 (10%) / 1 means 0.0000000000001 (0.0000001%) / 1,000,000,000,000 means 1 (100%)\n     * @return It returns the tax percentage\n     */\n    function _calculateTaxOverflow(uint256 _totalAmountPool, uint256 _raisingAmountPool)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 ratioOverflow = _totalAmountPool.div(_raisingAmountPool);\n\n        if (ratioOverflow >= 1500) {\n            return 500000000;\n            // 0.05%\n        } else if (ratioOverflow >= 1000) {\n            return 1000000000;\n            // 0.1%\n        } else if (ratioOverflow >= 500) {\n            return 2000000000;\n            // 0.2%\n        } else if (ratioOverflow >= 250) {\n            return 2500000000;\n            // 0.25%\n        } else if (ratioOverflow >= 100) {\n            return 3000000000;\n            // 0.3%\n        } else if (ratioOverflow >= 50) {\n            return 5000000000;\n            // 0.5%\n        } else {\n            return 10000000000;\n            // 1%\n        }\n    }\n\n    /**\n     * @notice It calculates the offering amount for a user and the number of raising tokens to transfer back.\n     * @param _user: user address\n     * @param _pid: pool id\n     * @return {uint256, uint256, uint256} It returns the offering amount, the refunding amount (in raising tokens),\n     * and the tax (if any, else 0)\n     */\n    function _calculateOfferingAndRefundingAmountsPool(address _user, uint8 _pid)\n    internal\n    view\n    returns (\n        uint256,\n        uint256,\n        uint256\n    )\n    {\n        uint256 userOfferingAmount;\n        uint256 userRefundingAmount;\n        uint256 taxAmount;\n\n        if (_poolInformation[_pid].totalAmountPool > _poolInformation[_pid].raisingAmountPool) {\n            // Calculate allocation for the user\n            uint256 allocation = _getUserAllocationPool(_user, _pid);\n\n            // Calculate the offering amount for the user based on the offeringAmount for the pool\n            userOfferingAmount = _poolInformation[_pid].offeringAmountPool.mul(allocation).div(1e12);\n\n            // Calculate the payAmount\n            uint256 payAmount = _poolInformation[_pid].raisingAmountPool.mul(allocation).div(1e12);\n\n            // Calculate the pre-tax refunding amount\n            userRefundingAmount = _userInfo[_user][_pid].amountPool.sub(payAmount);\n\n            // Retrieve the tax rate\n            if (_poolInformation[_pid].hasTax) {\n                uint256 taxOverflow = _calculateTaxOverflow(\n                    _poolInformation[_pid].totalAmountPool,\n                    _poolInformation[_pid].raisingAmountPool\n                );\n\n                // Calculate the final taxAmount\n                taxAmount = userRefundingAmount.mul(taxOverflow).div(1e12);\n\n                // Adjust the refunding amount\n                userRefundingAmount = userRefundingAmount.sub(taxAmount);\n            }\n        } else {\n            userRefundingAmount = 0;\n            taxAmount = 0;\n            // _userInfo[_user] / (raisingAmount / offeringAmount)\n            userOfferingAmount = _userInfo[_user][_pid].amountPool.mul(_poolInformation[_pid].offeringAmountPool).div(\n                _poolInformation[_pid].raisingAmountPool\n            );\n        }\n        return (userOfferingAmount, userRefundingAmount, taxAmount);\n    }\n\n    /**\n     * @notice It returns the user allocation for pool\n     * @dev 100,000,000,000 means 0.1 (10%) / 1 means 0.0000000000001 (0.0000001%) / 1,000,000,000,000 means 1 (100%)\n     * @param _user: user address\n     * @param _pid: pool id\n     * @return it returns the user's share of pool\n     */\n    function _getUserAllocationPool(address _user, uint8 _pid) internal view returns (uint256) {\n        if (_poolInformation[_pid].totalAmountPool > 0) {\n            return _userInfo[_user][_pid].amountPool.mul(1e18).div(_poolInformation[_pid].totalAmountPool.mul(1e6));\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Check if an address is a contract\n     */\n    function _isContract(address _addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/interfaces/IVotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IVotingEscrow {\n    function balanceOfT(address addr, uint256 _t) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/ifo/IFODeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./IFOInitializable.sol\";\n\n/**\n * @title IFODeployer\n */\ncontract IFODeployer is Ownable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX_BUFFER_TIME_INTERVAL = 7 * 86400; // 1 week\n\n    event AdminTokenRecovery(address indexed tokenRecovered, uint256 amount);\n    event NewIFOContract(address indexed ifoAddress);\n\n    /**\n     * @notice Constructor\n     */\n    constructor() public {\n        //\n    }\n\n    /**\n     * @notice It deploy the IFO contract and initializes the contract.\n     * @param _offeringToken: the token that is offered for the IFO\n     * @param _startTime: the start timestamp for the IFO\n     * @param _endTime: the end timestamp for the IFO\n     * @param _adminAddress: the admin address for handling tokens\n     */\n    function deployIFO(\n        address _offeringToken,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _adminAddress,\n        address _votingEscrowAddress,\n        address _burnAddress,\n        address _receiverAddress\n    ) external onlyOwner {\n        require(IERC20(_offeringToken).totalSupply() >= 0);\n        require(_endTime < (block.timestamp + MAX_BUFFER_TIME_INTERVAL), \"Operations: EndTime too far\");\n        require(_startTime < _endTime, \"Operations: StartTime must be inferior to endTime\");\n        require(_startTime > block.timestamp, \"Operations: StartTime must be greater than current timestamp\");\n\n        bytes memory bytecode = type(IFOInitializable).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(_offeringToken, _startTime, _endTime));\n        address ifoAddress;\n\n        assembly {\n            ifoAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n\n        IFOInitializable(ifoAddress).initialize(\n            _offeringToken,\n            _startTime,\n            _endTime,\n            MAX_BUFFER_TIME_INTERVAL,\n            _adminAddress,\n            _votingEscrowAddress,\n            _burnAddress,\n            _receiverAddress\n        );\n\n        emit NewIFOContract(ifoAddress);\n    }\n\n    /**\n     * @notice It allows the admin to recover wrong tokens sent to the contract\n     * @param _tokenAddress: the address of the token to withdraw\n     * @dev This function is only callable by admin.\n     */\n    function recoverWrongTokens(address _tokenAddress) external onlyOwner {\n        uint256 balanceToRecover = IERC20(_tokenAddress).balanceOf(address(this));\n        require(balanceToRecover > 0, \"Operations: Balance must be > 0\");\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), balanceToRecover);\n\n        emit AdminTokenRecovery(_tokenAddress, balanceToRecover);\n    }\n}"
    },
    "contracts/incentives/SimpleIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IOnwardIncentivesController.sol\";\n\ncontract SimpleIncentivesController is IOnwardIncentivesController, Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable override rewardToken;\n    IERC20 public immutable lpToken;\n    bool public immutable isNative;\n    // It is who call onReward method\n    address public immutable operator;\n    // always be masterchef\n    address public immutable originUser;\n\n    address private _nextIncentivesController;\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n        uint256 unpaidRewards;\n    }\n\n    struct PoolInfo {\n        uint256 accTokenPerShare;\n        uint256 lastRewardTimestamp;\n    }\n\n    PoolInfo public poolInfo;\n    /// @notice Info of each user that stakes LP tokens.\n    mapping(address => UserInfo) public userInfo;\n\n    uint256 public tokenPerSec;\n\n    uint256 private ACC_TOKEN_PRECISION;\n\n    event OnReward(address indexed user, uint256 amount);\n    event RewardRateUpdated(uint256 oldRate, uint256 newRate);\n\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"onlyOperator: only operator can call this function\");\n        _;\n    }\n\n    constructor(\n        IERC20 _rewardToken,\n        IERC20 _lpToken,\n        uint256 _tokenPerSec,\n        address _operator,\n        address _originUser,\n        bool _isNative\n    ) public {\n        require(Address.isContract(address(_rewardToken)), \"constructor: reward token must be a valid contract\");\n        require(Address.isContract(address(_lpToken)), \"constructor: LP token must be a valid contract\");\n        require(Address.isContract(_operator), \"constructor: operator must be a valid contract\");\n        require(Address.isContract(_originUser), \"constructor: originUser must be a valid contract\");\n        require(_tokenPerSec <= 1e30, \"constructor: token per seconds can't be greater than 1e30\");\n\n        rewardToken = _rewardToken;\n        lpToken = _lpToken;\n        tokenPerSec = _tokenPerSec;\n        operator = _operator;\n        originUser = _originUser;\n        isNative = _isNative;\n        poolInfo = PoolInfo({lastRewardTimestamp: block.timestamp, accTokenPerShare: 0});\n\n        // Given the fraction, tokenReward * ACC_TOKEN_PRECISION / lpSupply\n        ACC_TOKEN_PRECISION = 1e36;\n    }\n\n    /// @notice Update reward variables of the given poolInfo.\n    /// @return pool Returns the pool that was updated.\n    function updatePool() public returns (PoolInfo memory pool) {\n        pool = poolInfo;\n\n        if (block.timestamp > pool.lastRewardTimestamp) {\n            uint256 lpSupply = lpToken.balanceOf(originUser);\n\n            if (lpSupply > 0) {\n                uint256 timeElapsed = block.timestamp.sub(pool.lastRewardTimestamp);\n                uint256 tokenReward = timeElapsed.mul(tokenPerSec);\n                pool.accTokenPerShare = pool.accTokenPerShare.add((tokenReward.mul(ACC_TOKEN_PRECISION) / lpSupply));\n            }\n\n            pool.lastRewardTimestamp = block.timestamp;\n            poolInfo = pool;\n        }\n    }\n\n    function setNextIncentivesController(address nextIncentivesController) external onlyOwner {\n        _nextIncentivesController = nextIncentivesController;\n    }\n\n    /// @notice Sets the distribution reward rate. This will also update the poolInfo.\n    /// @param _tokenPerSec The number of tokens to distribute per second\n    function setRewardRate(uint256 _tokenPerSec) external onlyOwner {\n        updatePool();\n\n        uint256 oldRate = tokenPerSec;\n        tokenPerSec = _tokenPerSec;\n\n        emit RewardRateUpdated(oldRate, _tokenPerSec);\n    }\n\n    /// @notice Function called by operator whenever staker claims harvest. Allows staker to also receive a 2nd reward token.\n    /// @param _user Address of user\n    /// @param _lpAmount Number of LP tokens the user has\n    function onReward(address _user, uint256 _lpAmount) external override onlyOperator nonReentrant {\n        updatePool();\n        PoolInfo memory pool = poolInfo;\n        UserInfo storage user = userInfo[_user];\n        uint256 pending;\n        if (user.amount > 0) {\n            pending = (user.amount.mul(pool.accTokenPerShare) / ACC_TOKEN_PRECISION).sub(user.rewardDebt).add(\n                user.unpaidRewards\n            );\n\n            if (isNative) {\n                uint256 balance = address(this).balance;\n                if (pending > balance) {\n                    (bool success,) = _user.call{value : balance}(\"\");\n                    require(success, \"Transfer failed\");\n                    user.unpaidRewards = pending - balance;\n                } else {\n                    (bool success,) = _user.call{value : pending}(\"\");\n                    require(success, \"Transfer failed\");\n                    user.unpaidRewards = 0;\n                }\n            } else {\n                uint256 balance = rewardToken.balanceOf(address(this));\n                if (pending > balance) {\n                    rewardToken.safeTransfer(_user, balance);\n                    user.unpaidRewards = pending - balance;\n                } else {\n                    rewardToken.safeTransfer(_user, pending);\n                    user.unpaidRewards = 0;\n                }\n            }\n        }\n\n        user.amount = _lpAmount;\n        user.rewardDebt = user.amount.mul(pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n\n        // Interactions\n        if (_nextIncentivesController != address(0)) {\n            IOnwardIncentivesController(_nextIncentivesController).onReward(_user, _lpAmount);\n        }\n\n        emit OnReward(_user, pending - user.unpaidRewards);\n    }\n\n    /// @notice View function to see pending tokens\n    /// @param _user Address of user.\n    /// @return pending reward for a given user.\n    function pendingTokens(address _user) external view override returns (uint256 pending) {\n        PoolInfo memory pool = poolInfo;\n        UserInfo storage user = userInfo[_user];\n\n        uint256 accTokenPerShare = pool.accTokenPerShare;\n        uint256 lpSupply = lpToken.balanceOf(originUser);\n\n        if (block.timestamp > pool.lastRewardTimestamp && lpSupply != 0) {\n            uint256 timeElapsed = block.timestamp.sub(pool.lastRewardTimestamp);\n            uint256 tokenReward = timeElapsed.mul(tokenPerSec);\n            accTokenPerShare = accTokenPerShare.add(tokenReward.mul(ACC_TOKEN_PRECISION).div(lpSupply));\n        }\n\n        pending = (user.amount.mul(accTokenPerShare) / ACC_TOKEN_PRECISION).sub(user.rewardDebt).add(\n            user.unpaidRewards\n        );\n    }\n\n    /// @notice In case rewarder is stopped before emissions finished, this function allows\n    /// withdrawal of remaining tokens.\n    function emergencyWithdraw() public onlyOwner {\n        if (isNative) {\n            (bool success,) = msg.sender.call{value : address(this).balance}(\"\");\n            require(success, \"Transfer failed\");\n        } else {\n            rewardToken.safeTransfer(address(msg.sender), rewardToken.balanceOf(address(this)));\n        }\n    }\n\n    /// @notice View function to see balance of reward token.\n    function balance() external view returns (uint256) {\n        if (isNative) {\n            return address(this).balance;\n        } else {\n            return rewardToken.balanceOf(address(this));\n        }\n    }\n\n    function getNextIncentivesController() external view override returns (address) {\n        return _nextIncentivesController;\n    }\n\n    /// @notice payable function needed to receive AVAX\n    receive() external payable {}\n}"
    },
    "contracts/interfaces/IEvmoSwapERC20.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IEvmoSwapERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}